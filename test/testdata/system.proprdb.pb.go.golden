// Code generated by protoc-gen-proprdb. DO NOT EDIT.

package genexample

import (
	"context"
	"crypto/rand"
	"database/sql"
	"encoding/binary"
	"errors"
	"fmt"
	"strings"
	"time"

	"google.golang.org/protobuf/proto"
)

type DBTX interface {
	ExecContext(context.Context, string, ...any) (sql.Result, error)
	QueryContext(context.Context, string, ...any) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...any) *sql.Row
}

func proprdbNowNs() int64 {
	return time.Now().UnixNano()
}

func proprdbUUIDv7() (string, error) {
	var uuidBytes [16]byte
	if _, err := rand.Read(uuidBytes[:]); err != nil {
		return "", fmt.Errorf("generate random bytes for uuidv7: %w", err)
	}
	milliseconds := uint64(time.Now().UnixMilli())
	uuidBytes[0] = byte(milliseconds >> 40)
	uuidBytes[1] = byte(milliseconds >> 32)
	uuidBytes[2] = byte(milliseconds >> 24)
	uuidBytes[3] = byte(milliseconds >> 16)
	uuidBytes[4] = byte(milliseconds >> 8)
	uuidBytes[5] = byte(milliseconds)
	uuidBytes[6] = (uuidBytes[6] & 0x0f) | 0x70
	uuidBytes[8] = (uuidBytes[8] & 0x3f) | 0x80
	segment1 := binary.BigEndian.Uint32(uuidBytes[0:4])
	segment2 := binary.BigEndian.Uint16(uuidBytes[4:6])
	segment3 := binary.BigEndian.Uint16(uuidBytes[6:8])
	segment4 := binary.BigEndian.Uint16(uuidBytes[8:10])
	segment5High := binary.BigEndian.Uint16(uuidBytes[10:12])
	segment5Low := binary.BigEndian.Uint32(uuidBytes[12:16])
	segment5 := (uint64(segment5High) << 32) | uint64(segment5Low)
	return fmt.Sprintf("%08x-%04x-%04x-%04x-%012x", segment1, segment2, segment3, segment4, segment5), nil
}

const PersonTableName = "generatedtest_example_person"
const PersonProjectionSchema = "name:string;age:int64"
const PersonCreateTableSQL = "CREATE TABLE IF NOT EXISTS \"generatedtest_example_person\" (\"id\" TEXT PRIMARY KEY, \"at_ns\" INTEGER NOT NULL, \"data\" BLOB NOT NULL, \"name\" TEXT NOT NULL DEFAULT '', \"age\" INTEGER NOT NULL DEFAULT 0)"
const PersonInsertSQL = "INSERT INTO \"generatedtest_example_person\" (\"id\", \"at_ns\", \"data\", \"name\", \"age\") VALUES (?, ?, ?, ?, ?)"
const PersonUpsertSQL = "INSERT INTO \"generatedtest_example_person\" (\"id\", \"at_ns\", \"data\", \"name\", \"age\") VALUES (?, ?, ?, ?, ?) ON CONFLICT(id) DO UPDATE SET \"at_ns\" = excluded.\"at_ns\", \"data\" = excluded.\"data\", \"name\" = excluded.\"name\", \"age\" = excluded.\"age\""
const PersonReprojectSQL = "UPDATE \"generatedtest_example_person\" SET \"name\" = ?, \"age\" = ? WHERE id = ?"

type PersonRow struct {
	ID   string
	AtNs int64
	Data *Person
}

type PersonTable struct {
	q DBTX
}

func NewPersonTable(q DBTX) *PersonTable {
	return &PersonTable{q: q}
}

func (t *PersonTable) Init() error {
	if t.q == nil {
		return errors.New("nil DBTX")
	}
	ctx := context.Background()
	if _, err := t.q.ExecContext(ctx, `CREATE TABLE IF NOT EXISTS _deleted (table_name TEXT NOT NULL, id TEXT NOT NULL, at_ns INTEGER NOT NULL, PRIMARY KEY (table_name, id))`); err != nil {
		return fmt.Errorf("create _deleted table: %w", err)
	}
	if _, err := t.q.ExecContext(ctx, `CREATE TABLE IF NOT EXISTS _proprdb_schema (table_name TEXT PRIMARY KEY, schema_hash TEXT NOT NULL)`); err != nil {
		return fmt.Errorf("create _proprdb_schema table: %w", err)
	}
	if _, err := t.q.ExecContext(ctx, PersonCreateTableSQL); err != nil {
		return fmt.Errorf("create table %s: %w", PersonTableName, err)
	}
	columnRows, err := t.q.QueryContext(ctx, `PRAGMA table_info("`+PersonTableName+`")`)
	if err != nil {
		return fmt.Errorf("read columns for %s: %w", PersonTableName, err)
	}
	defer func() { _ = columnRows.Close() }()
	existingColumns := make(map[string]bool)
	for columnRows.Next() {
		var cid int
		var name string
		var colType string
		var notNull int
		var defaultValue any
		var pk int
		if err := columnRows.Scan(&cid, &name, &colType, &notNull, &defaultValue, &pk); err != nil {
			return fmt.Errorf("scan pragma row: %w", err)
		}
		existingColumns[name] = true
	}
	if err := columnRows.Err(); err != nil {
		return fmt.Errorf("iterate pragma rows: %w", err)
	}
	if !existingColumns["name"] {
		if _, err := t.q.ExecContext(ctx, `ALTER TABLE "`+PersonTableName+`" ADD COLUMN "name" TEXT NOT NULL DEFAULT ''`); err != nil {
			return fmt.Errorf("add projection column name to %s: %w", PersonTableName, err)
		}
	}
	if !existingColumns["age"] {
		if _, err := t.q.ExecContext(ctx, `ALTER TABLE "`+PersonTableName+`" ADD COLUMN "age" INTEGER NOT NULL DEFAULT 0`); err != nil {
			return fmt.Errorf("add projection column age to %s: %w", PersonTableName, err)
		}
	}
	var currentSchema string
	schemaErr := t.q.QueryRowContext(ctx, `SELECT schema_hash FROM _proprdb_schema WHERE table_name = ?`, PersonTableName).Scan(&currentSchema)
	if errors.Is(schemaErr, sql.ErrNoRows) {
		if _, insertErr := t.q.ExecContext(ctx, `INSERT INTO _proprdb_schema (table_name, schema_hash) VALUES (?, ?)`, PersonTableName, PersonProjectionSchema); insertErr != nil {
			return fmt.Errorf("insert schema hash for %s: %w", PersonTableName, insertErr)
		}
		return nil
	}
	if schemaErr != nil {
		return fmt.Errorf("select schema hash for %s: %w", PersonTableName, schemaErr)
	}
	if currentSchema == PersonProjectionSchema {
		return nil
	}
	if err := t.reproject(); err != nil {
		return fmt.Errorf("reproject table %s: %w", PersonTableName, err)
	}
	if _, err := t.q.ExecContext(ctx, `UPDATE _proprdb_schema SET schema_hash = ? WHERE table_name = ?`, PersonProjectionSchema, PersonTableName); err != nil {
		return fmt.Errorf("update schema hash for %s: %w", PersonTableName, err)
	}
	return nil
}

func (t *PersonTable) Select(where string, args ...any) ([]PersonRow, error) {
	if t.q == nil {
		return nil, errors.New("nil DBTX")
	}
	ctx := context.Background()
	query := `SELECT id, at_ns, data FROM "` + PersonTableName + `"`
	if strings.TrimSpace(where) != "" {
		query += " WHERE " + where
	}
	rows, err := t.q.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("select from %s: %w", PersonTableName, err)
	}
	defer func() { _ = rows.Close() }()
	result := make([]PersonRow, 0)
	for rows.Next() {
		var id string
		var atNs int64
		var dataBytes []byte
		if err := rows.Scan(&id, &atNs, &dataBytes); err != nil {
			return nil, fmt.Errorf("scan row from %s: %w", PersonTableName, err)
		}
		data := &Person{}
		if err := proto.Unmarshal(dataBytes, data); err != nil {
			return nil, fmt.Errorf("unmarshal Person row: %w", err)
		}
		result = append(result, PersonRow{ID: id, AtNs: atNs, Data: data})
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("iterate rows from %s: %w", PersonTableName, err)
	}
	return result, nil
}

func (t *PersonTable) Insert(data *Person) (PersonRow, error) {
	if t.q == nil {
		return PersonRow{}, errors.New("nil DBTX")
	}
	if data == nil {
		return PersonRow{}, errors.New("nil data")
	}
	ctx := context.Background()
	id, err := proprdbUUIDv7()
	if err != nil {
		return PersonRow{}, fmt.Errorf("generate uuidv7: %w", err)
	}
	atNs := proprdbNowNs()
	dataBytes, err := proto.Marshal(data)
	if err != nil {
		return PersonRow{}, fmt.Errorf("marshal Person: %w", err)
	}
	if _, err := t.q.ExecContext(ctx, `DELETE FROM _deleted WHERE table_name = ? AND id = ?`, PersonTableName, id); err != nil {
		return PersonRow{}, fmt.Errorf("delete tombstone for %s/%s: %w", PersonTableName, id, err)
	}
	insertArgs := []any{id, atNs, dataBytes}
	insertArgs = append(insertArgs, data.GetName())
	insertArgs = append(insertArgs, data.GetAge())
	if _, err := t.q.ExecContext(ctx, PersonInsertSQL, insertArgs...); err != nil {
		return PersonRow{}, fmt.Errorf("insert into %s: %w", PersonTableName, err)
	}
	return PersonRow{ID: id, AtNs: atNs, Data: data}, nil
}

func (t *PersonTable) UpdateByID(id string, data *Person) (PersonRow, error) {
	if t.q == nil {
		return PersonRow{}, errors.New("nil DBTX")
	}
	if id == "" {
		return PersonRow{}, errors.New("empty id")
	}
	if data == nil {
		return PersonRow{}, errors.New("nil data")
	}
	ctx := context.Background()
	atNs := proprdbNowNs()
	dataBytes, err := proto.Marshal(data)
	if err != nil {
		return PersonRow{}, fmt.Errorf("marshal Person: %w", err)
	}
	if _, err := t.q.ExecContext(ctx, `DELETE FROM _deleted WHERE table_name = ? AND id = ?`, PersonTableName, id); err != nil {
		return PersonRow{}, fmt.Errorf("delete tombstone for %s/%s: %w", PersonTableName, id, err)
	}
	updateArgs := []any{id, atNs, dataBytes}
	updateArgs = append(updateArgs, data.GetName())
	updateArgs = append(updateArgs, data.GetAge())
	if _, err := t.q.ExecContext(ctx, PersonUpsertSQL, updateArgs...); err != nil {
		return PersonRow{}, fmt.Errorf("upsert into %s: %w", PersonTableName, err)
	}
	return PersonRow{ID: id, AtNs: atNs, Data: data}, nil
}

func (t *PersonTable) UpdateRow(row PersonRow) (PersonRow, error) {
	if t.q == nil {
		return PersonRow{}, errors.New("nil DBTX")
	}
	if row.ID == "" {
		return PersonRow{}, errors.New("empty id")
	}
	if row.Data == nil {
		return PersonRow{}, errors.New("nil data")
	}
	return t.UpdateByID(row.ID, row.Data)
}

func (t *PersonTable) DeleteByID(id string) error {
	if t.q == nil {
		return errors.New("nil DBTX")
	}
	if id == "" {
		return errors.New("empty id")
	}
	ctx := context.Background()
	atNs := proprdbNowNs()
	if _, err := t.q.ExecContext(ctx, `INSERT INTO _deleted (table_name, id, at_ns) VALUES (?, ?, ?) ON CONFLICT(table_name, id) DO UPDATE SET at_ns = excluded.at_ns`, PersonTableName, id, atNs); err != nil {
		return fmt.Errorf("insert tombstone for %s/%s: %w", PersonTableName, id, err)
	}
	if _, err := t.q.ExecContext(ctx, `DELETE FROM "`+PersonTableName+`" WHERE id = ?`, id); err != nil {
		return fmt.Errorf("delete from %s/%s: %w", PersonTableName, id, err)
	}
	return nil
}

func (t *PersonTable) DeleteRow(row PersonRow) error {
	if t.q == nil {
		return errors.New("nil DBTX")
	}
	if row.ID == "" {
		return errors.New("empty id")
	}
	return t.DeleteByID(row.ID)
}

func (t *PersonTable) reproject() error {
	ctx := context.Background()
	rows, err := t.q.QueryContext(ctx, `SELECT id, data FROM "`+PersonTableName+`"`)
	if err != nil {
		return fmt.Errorf("query rows for reprojection: %w", err)
	}
	type reprojectRow struct {
		id        string
		dataBytes []byte
	}
	rowBuffer := make([]reprojectRow, 0)
	for rows.Next() {
		var id string
		var dataBytes []byte
		if err := rows.Scan(&id, &dataBytes); err != nil {
			return fmt.Errorf("scan reprojection row: %w", err)
		}
		copiedData := make([]byte, len(dataBytes))
		copy(copiedData, dataBytes)
		rowBuffer = append(rowBuffer, reprojectRow{id: id, dataBytes: copiedData})
	}
	if err := rows.Err(); err != nil {
		return fmt.Errorf("iterate reprojection rows: %w", err)
	}
	if err := rows.Close(); err != nil {
		return fmt.Errorf("close reprojection rows: %w", err)
	}
	for _, row := range rowBuffer {
		data := &Person{}
		if err := proto.Unmarshal(row.dataBytes, data); err != nil {
			return fmt.Errorf("unmarshal reprojection row: %w", err)
		}
		reprojectArgs := []any{}
		reprojectArgs = append(reprojectArgs, data.GetName())
		reprojectArgs = append(reprojectArgs, data.GetAge())
		reprojectArgs = append(reprojectArgs, row.id)
		if _, err := t.q.ExecContext(ctx, PersonReprojectSQL, reprojectArgs...); err != nil {
			return fmt.Errorf("reproject row %s: %w", row.id, err)
		}
	}
	return nil
}

const NoteTableName = "generatedtest_example_note"
const NoteProjectionSchema = "text:string"
const NoteCreateTableSQL = "CREATE TABLE IF NOT EXISTS \"generatedtest_example_note\" (\"id\" TEXT PRIMARY KEY, \"at_ns\" INTEGER NOT NULL, \"data\" BLOB NOT NULL, \"text\" TEXT NOT NULL DEFAULT '')"
const NoteInsertSQL = "INSERT INTO \"generatedtest_example_note\" (\"id\", \"at_ns\", \"data\", \"text\") VALUES (?, ?, ?, ?)"
const NoteUpsertSQL = "INSERT INTO \"generatedtest_example_note\" (\"id\", \"at_ns\", \"data\", \"text\") VALUES (?, ?, ?, ?) ON CONFLICT(id) DO UPDATE SET \"at_ns\" = excluded.\"at_ns\", \"data\" = excluded.\"data\", \"text\" = excluded.\"text\""
const NoteReprojectSQL = "UPDATE \"generatedtest_example_note\" SET \"text\" = ? WHERE id = ?"

type NoteRow struct {
	ID   string
	AtNs int64
	Data *Note
}

type NoteTable struct {
	q DBTX
}

func NewNoteTable(q DBTX) *NoteTable {
	return &NoteTable{q: q}
}

func (t *NoteTable) Init() error {
	if t.q == nil {
		return errors.New("nil DBTX")
	}
	ctx := context.Background()
	if _, err := t.q.ExecContext(ctx, `CREATE TABLE IF NOT EXISTS _deleted (table_name TEXT NOT NULL, id TEXT NOT NULL, at_ns INTEGER NOT NULL, PRIMARY KEY (table_name, id))`); err != nil {
		return fmt.Errorf("create _deleted table: %w", err)
	}
	if _, err := t.q.ExecContext(ctx, `CREATE TABLE IF NOT EXISTS _proprdb_schema (table_name TEXT PRIMARY KEY, schema_hash TEXT NOT NULL)`); err != nil {
		return fmt.Errorf("create _proprdb_schema table: %w", err)
	}
	if _, err := t.q.ExecContext(ctx, NoteCreateTableSQL); err != nil {
		return fmt.Errorf("create table %s: %w", NoteTableName, err)
	}
	columnRows, err := t.q.QueryContext(ctx, `PRAGMA table_info("`+NoteTableName+`")`)
	if err != nil {
		return fmt.Errorf("read columns for %s: %w", NoteTableName, err)
	}
	defer func() { _ = columnRows.Close() }()
	existingColumns := make(map[string]bool)
	for columnRows.Next() {
		var cid int
		var name string
		var colType string
		var notNull int
		var defaultValue any
		var pk int
		if err := columnRows.Scan(&cid, &name, &colType, &notNull, &defaultValue, &pk); err != nil {
			return fmt.Errorf("scan pragma row: %w", err)
		}
		existingColumns[name] = true
	}
	if err := columnRows.Err(); err != nil {
		return fmt.Errorf("iterate pragma rows: %w", err)
	}
	if !existingColumns["text"] {
		if _, err := t.q.ExecContext(ctx, `ALTER TABLE "`+NoteTableName+`" ADD COLUMN "text" TEXT NOT NULL DEFAULT ''`); err != nil {
			return fmt.Errorf("add projection column text to %s: %w", NoteTableName, err)
		}
	}
	var currentSchema string
	schemaErr := t.q.QueryRowContext(ctx, `SELECT schema_hash FROM _proprdb_schema WHERE table_name = ?`, NoteTableName).Scan(&currentSchema)
	if errors.Is(schemaErr, sql.ErrNoRows) {
		if _, insertErr := t.q.ExecContext(ctx, `INSERT INTO _proprdb_schema (table_name, schema_hash) VALUES (?, ?)`, NoteTableName, NoteProjectionSchema); insertErr != nil {
			return fmt.Errorf("insert schema hash for %s: %w", NoteTableName, insertErr)
		}
		return nil
	}
	if schemaErr != nil {
		return fmt.Errorf("select schema hash for %s: %w", NoteTableName, schemaErr)
	}
	if currentSchema == NoteProjectionSchema {
		return nil
	}
	if err := t.reproject(); err != nil {
		return fmt.Errorf("reproject table %s: %w", NoteTableName, err)
	}
	if _, err := t.q.ExecContext(ctx, `UPDATE _proprdb_schema SET schema_hash = ? WHERE table_name = ?`, NoteProjectionSchema, NoteTableName); err != nil {
		return fmt.Errorf("update schema hash for %s: %w", NoteTableName, err)
	}
	return nil
}

func (t *NoteTable) Select(where string, args ...any) ([]NoteRow, error) {
	if t.q == nil {
		return nil, errors.New("nil DBTX")
	}
	ctx := context.Background()
	query := `SELECT id, at_ns, data FROM "` + NoteTableName + `"`
	if strings.TrimSpace(where) != "" {
		query += " WHERE " + where
	}
	rows, err := t.q.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("select from %s: %w", NoteTableName, err)
	}
	defer func() { _ = rows.Close() }()
	result := make([]NoteRow, 0)
	for rows.Next() {
		var id string
		var atNs int64
		var dataBytes []byte
		if err := rows.Scan(&id, &atNs, &dataBytes); err != nil {
			return nil, fmt.Errorf("scan row from %s: %w", NoteTableName, err)
		}
		data := &Note{}
		if err := proto.Unmarshal(dataBytes, data); err != nil {
			return nil, fmt.Errorf("unmarshal Note row: %w", err)
		}
		result = append(result, NoteRow{ID: id, AtNs: atNs, Data: data})
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("iterate rows from %s: %w", NoteTableName, err)
	}
	return result, nil
}

func (t *NoteTable) Insert(data *Note) (NoteRow, error) {
	if t.q == nil {
		return NoteRow{}, errors.New("nil DBTX")
	}
	if data == nil {
		return NoteRow{}, errors.New("nil data")
	}
	ctx := context.Background()
	id, err := proprdbUUIDv7()
	if err != nil {
		return NoteRow{}, fmt.Errorf("generate uuidv7: %w", err)
	}
	atNs := proprdbNowNs()
	dataBytes, err := proto.Marshal(data)
	if err != nil {
		return NoteRow{}, fmt.Errorf("marshal Note: %w", err)
	}
	if _, err := t.q.ExecContext(ctx, `DELETE FROM _deleted WHERE table_name = ? AND id = ?`, NoteTableName, id); err != nil {
		return NoteRow{}, fmt.Errorf("delete tombstone for %s/%s: %w", NoteTableName, id, err)
	}
	insertArgs := []any{id, atNs, dataBytes}
	insertArgs = append(insertArgs, data.GetText())
	if _, err := t.q.ExecContext(ctx, NoteInsertSQL, insertArgs...); err != nil {
		return NoteRow{}, fmt.Errorf("insert into %s: %w", NoteTableName, err)
	}
	return NoteRow{ID: id, AtNs: atNs, Data: data}, nil
}

func (t *NoteTable) UpdateByID(id string, data *Note) (NoteRow, error) {
	if t.q == nil {
		return NoteRow{}, errors.New("nil DBTX")
	}
	if id == "" {
		return NoteRow{}, errors.New("empty id")
	}
	if data == nil {
		return NoteRow{}, errors.New("nil data")
	}
	ctx := context.Background()
	atNs := proprdbNowNs()
	dataBytes, err := proto.Marshal(data)
	if err != nil {
		return NoteRow{}, fmt.Errorf("marshal Note: %w", err)
	}
	if _, err := t.q.ExecContext(ctx, `DELETE FROM _deleted WHERE table_name = ? AND id = ?`, NoteTableName, id); err != nil {
		return NoteRow{}, fmt.Errorf("delete tombstone for %s/%s: %w", NoteTableName, id, err)
	}
	updateArgs := []any{id, atNs, dataBytes}
	updateArgs = append(updateArgs, data.GetText())
	if _, err := t.q.ExecContext(ctx, NoteUpsertSQL, updateArgs...); err != nil {
		return NoteRow{}, fmt.Errorf("upsert into %s: %w", NoteTableName, err)
	}
	return NoteRow{ID: id, AtNs: atNs, Data: data}, nil
}

func (t *NoteTable) UpdateRow(row NoteRow) (NoteRow, error) {
	if t.q == nil {
		return NoteRow{}, errors.New("nil DBTX")
	}
	if row.ID == "" {
		return NoteRow{}, errors.New("empty id")
	}
	if row.Data == nil {
		return NoteRow{}, errors.New("nil data")
	}
	return t.UpdateByID(row.ID, row.Data)
}

func (t *NoteTable) DeleteByID(id string) error {
	if t.q == nil {
		return errors.New("nil DBTX")
	}
	if id == "" {
		return errors.New("empty id")
	}
	ctx := context.Background()
	atNs := proprdbNowNs()
	if _, err := t.q.ExecContext(ctx, `INSERT INTO _deleted (table_name, id, at_ns) VALUES (?, ?, ?) ON CONFLICT(table_name, id) DO UPDATE SET at_ns = excluded.at_ns`, NoteTableName, id, atNs); err != nil {
		return fmt.Errorf("insert tombstone for %s/%s: %w", NoteTableName, id, err)
	}
	if _, err := t.q.ExecContext(ctx, `DELETE FROM "`+NoteTableName+`" WHERE id = ?`, id); err != nil {
		return fmt.Errorf("delete from %s/%s: %w", NoteTableName, id, err)
	}
	return nil
}

func (t *NoteTable) DeleteRow(row NoteRow) error {
	if t.q == nil {
		return errors.New("nil DBTX")
	}
	if row.ID == "" {
		return errors.New("empty id")
	}
	return t.DeleteByID(row.ID)
}

func (t *NoteTable) reproject() error {
	ctx := context.Background()
	rows, err := t.q.QueryContext(ctx, `SELECT id, data FROM "`+NoteTableName+`"`)
	if err != nil {
		return fmt.Errorf("query rows for reprojection: %w", err)
	}
	type reprojectRow struct {
		id        string
		dataBytes []byte
	}
	rowBuffer := make([]reprojectRow, 0)
	for rows.Next() {
		var id string
		var dataBytes []byte
		if err := rows.Scan(&id, &dataBytes); err != nil {
			return fmt.Errorf("scan reprojection row: %w", err)
		}
		copiedData := make([]byte, len(dataBytes))
		copy(copiedData, dataBytes)
		rowBuffer = append(rowBuffer, reprojectRow{id: id, dataBytes: copiedData})
	}
	if err := rows.Err(); err != nil {
		return fmt.Errorf("iterate reprojection rows: %w", err)
	}
	if err := rows.Close(); err != nil {
		return fmt.Errorf("close reprojection rows: %w", err)
	}
	for _, row := range rowBuffer {
		data := &Note{}
		if err := proto.Unmarshal(row.dataBytes, data); err != nil {
			return fmt.Errorf("unmarshal reprojection row: %w", err)
		}
		reprojectArgs := []any{}
		reprojectArgs = append(reprojectArgs, data.GetText())
		reprojectArgs = append(reprojectArgs, row.id)
		if _, err := t.q.ExecContext(ctx, NoteReprojectSQL, reprojectArgs...); err != nil {
			return fmt.Errorf("reproject row %s: %w", row.id, err)
		}
	}
	return nil
}

type CRUD struct {
	Person *PersonTable
	Note   *NoteTable
}

func NewCRUD(q DBTX) *CRUD {
	return &CRUD{
		Person: NewPersonTable(q),
		Note:   NewNoteTable(q),
	}
}

func (c *CRUD) Init() error {
	if err := c.Person.Init(); err != nil {
		return fmt.Errorf("init Person table: %w", err)
	}
	if err := c.Note.Init(); err != nil {
		return fmt.Errorf("init Note table: %w", err)
	}
	return nil
}

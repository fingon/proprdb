// Code generated by protoc-gen-proprdb. DO NOT EDIT.

package genexample

import (
	"context"
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log/slog"
	"strings"

	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/known/anypb"
	rt "github.com/fingon/proprdb/rt"
)

type DBTX = rt.DBTX
type proprdbJSONLRecord = rt.JSONLRecord

const PersonTableName = "generatedtest_example_person"
const PersonTypeName = "generatedtest.example.Person"
const PersonProjectionSchema = "name:string;age:int64;idx:name;idx:name,age"
const PersonCreateTableSQL = "CREATE TABLE IF NOT EXISTS \"generatedtest_example_person\" (\"id\" TEXT PRIMARY KEY, \"at_ns\" INTEGER NOT NULL, \"data\" BLOB NOT NULL, \"name\" TEXT NOT NULL DEFAULT '', \"age\" INTEGER NOT NULL DEFAULT 0)"
const PersonInsertSQL = "INSERT INTO \"generatedtest_example_person\" (\"id\", \"at_ns\", \"data\", \"name\", \"age\") VALUES (?, ?, ?, ?, ?)"
const PersonUpsertSQL = "INSERT INTO \"generatedtest_example_person\" (\"id\", \"at_ns\", \"data\", \"name\", \"age\") VALUES (?, ?, ?, ?, ?) ON CONFLICT(id) DO UPDATE SET \"at_ns\" = excluded.\"at_ns\", \"data\" = excluded.\"data\", \"name\" = excluded.\"name\", \"age\" = excluded.\"age\""
const PersonGeneratedIndexPrefix = "idx_generatedtest_example_person__"
const PersonCreateIndexSQL1 = "CREATE INDEX IF NOT EXISTS \"idx_generatedtest_example_person__name\" ON \"generatedtest_example_person\" (\"name\")"
const PersonCreateIndexSQL2 = "CREATE INDEX IF NOT EXISTS \"idx_generatedtest_example_person__name_age\" ON \"generatedtest_example_person\" (\"name\", \"age\")"
const PersonReprojectSQL = "UPDATE \"generatedtest_example_person\" SET \"name\" = ?, \"age\" = ? WHERE id = ?"

type PersonRow struct {
	ID   string
	AtNs int64
	Data *Person
}

type PersonTable struct {
	q DBTX
}

func NewPersonTable(q DBTX) *PersonTable {
	return &PersonTable{q: q}
}

func (t *PersonTable) Init() error {
	if t.q == nil {
		return errors.New("nil DBTX")
	}
	if err := rt.EnsureCoreTables(t.q); err != nil {
		return err
	}
	ctx := context.Background()
	if _, err := t.q.ExecContext(ctx, PersonCreateTableSQL); err != nil {
		return fmt.Errorf("create table %s: %w", PersonTableName, err)
	}
	columnRows, err := t.q.QueryContext(ctx, `PRAGMA table_info("`+PersonTableName+`")`)
	if err != nil {
		return fmt.Errorf("read columns for %s: %w", PersonTableName, err)
	}
	existingColumns := make(map[string]bool)
	for columnRows.Next() {
		var cid int
		var name string
		var colType string
		var notNull int
		var defaultValue any
		var pk int
		if err := columnRows.Scan(&cid, &name, &colType, &notNull, &defaultValue, &pk); err != nil {
			if closeErr := rt.CloseRows(columnRows, "projection metadata"); closeErr != nil {
				return fmt.Errorf("scan pragma row: %w (additionally, %v)", err, closeErr)
			}
			return fmt.Errorf("scan pragma row: %w", err)
		}
		existingColumns[name] = true
	}
	if err := columnRows.Err(); err != nil {
		if closeErr := rt.CloseRows(columnRows, "projection metadata"); closeErr != nil {
			return fmt.Errorf("iterate pragma rows: %w (additionally, %v)", err, closeErr)
		}
		return fmt.Errorf("iterate pragma rows: %w", err)
	}
	if err := rt.CloseRows(columnRows, "projection metadata"); err != nil {
		return err
	}
	if !existingColumns["name"] {
		if _, err := t.q.ExecContext(ctx, `ALTER TABLE "`+PersonTableName+`" ADD COLUMN "name" TEXT NOT NULL DEFAULT ''`); err != nil {
			return fmt.Errorf("add projection column name to %s: %w", PersonTableName, err)
		}
	}
	if !existingColumns["age"] {
		if _, err := t.q.ExecContext(ctx, `ALTER TABLE "`+PersonTableName+`" ADD COLUMN "age" INTEGER NOT NULL DEFAULT 0`); err != nil {
			return fmt.Errorf("add projection column age to %s: %w", PersonTableName, err)
		}
	}
	if err := rt.EnsureManagedIndexes(t.q, PersonTableName, PersonGeneratedIndexPrefix, []string{
		PersonCreateIndexSQL1,
		PersonCreateIndexSQL2,
	}, []string{
		"idx_generatedtest_example_person__name",
		"idx_generatedtest_example_person__name_age",
	}); err != nil {
		return err
	}
	var currentSchema string
	schemaErr := t.q.QueryRowContext(ctx, `SELECT schema_hash FROM _proprdb_schema WHERE table_name = ?`, PersonTableName).Scan(&currentSchema)
	if errors.Is(schemaErr, sql.ErrNoRows) {
		if _, insertErr := t.q.ExecContext(ctx, `INSERT INTO _proprdb_schema (table_name, schema_hash) VALUES (?, ?)`, PersonTableName, PersonProjectionSchema); insertErr != nil {
			return fmt.Errorf("insert schema hash for %s: %w", PersonTableName, insertErr)
		}
	} else if schemaErr != nil {
		return fmt.Errorf("select schema hash for %s: %w", PersonTableName, schemaErr)
	} else if currentSchema != PersonProjectionSchema {
		if err := t.reproject(); err != nil {
			return fmt.Errorf("reproject table %s: %w", PersonTableName, err)
		}
		if _, err := t.q.ExecContext(ctx, `UPDATE _proprdb_schema SET schema_hash = ? WHERE table_name = ?`, PersonProjectionSchema, PersonTableName); err != nil {
			return fmt.Errorf("update schema hash for %s: %w", PersonTableName, err)
		}
	}
	if err := t.drainUnknownRows(PersonTypeName); err != nil {
		return fmt.Errorf("drain unknown rows for %s: %w", PersonTableName, err)
	}
	return nil
}

func (t *PersonTable) Select(where string, args ...any) ([]PersonRow, error) {
	if t.q == nil {
		return nil, errors.New("nil DBTX")
	}
	ctx := context.Background()
	query := `SELECT id, at_ns, data FROM "` + PersonTableName + `"`
	if strings.TrimSpace(where) != "" {
		query += " WHERE " + where
	}
	rows, err := t.q.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("select from %s: %w", PersonTableName, err)
	}
	result := make([]PersonRow, 0)
	for rows.Next() {
		var id string
		var atNs int64
		var dataBytes []byte
		if err := rows.Scan(&id, &atNs, &dataBytes); err != nil {
			if closeErr := rt.CloseRows(rows, "select"); closeErr != nil {
				return nil, fmt.Errorf("scan row from %s: %w (additionally, %v)", PersonTableName, err, closeErr)
			}
			return nil, fmt.Errorf("scan row from %s: %w", PersonTableName, err)
		}
		data := &Person{}
		if err := proto.Unmarshal(dataBytes, data); err != nil {
			if closeErr := rt.CloseRows(rows, "select"); closeErr != nil {
				return nil, fmt.Errorf("unmarshal Person row: %w (additionally, %v)", err, closeErr)
			}
			return nil, fmt.Errorf("unmarshal Person row: %w", err)
		}
		result = append(result, PersonRow{ID: id, AtNs: atNs, Data: data})
	}
	if err := rows.Err(); err != nil {
		if closeErr := rt.CloseRows(rows, "select"); closeErr != nil {
			return nil, fmt.Errorf("iterate rows from %s: %w (additionally, %v)", PersonTableName, err, closeErr)
		}
		return nil, fmt.Errorf("iterate rows from %s: %w", PersonTableName, err)
	}
	if err := rt.CloseRows(rows, "select"); err != nil {
		return nil, err
	}
	return result, nil
}

func (t *PersonTable) Insert(data *Person) (PersonRow, error) {
	if t.q == nil {
		return PersonRow{}, errors.New("nil DBTX")
	}
	if data == nil {
		return PersonRow{}, errors.New("nil data")
	}
	id, err := rt.UUIDv7()
	if err != nil {
		return PersonRow{}, fmt.Errorf("generate uuidv7: %w", err)
	}
	if err := rt.ValidateUUID(id); err != nil {
		return PersonRow{}, fmt.Errorf("validate generated id %s: %w", id, err)
	}
	return t.insertWithID(id, data)
}

func (t *PersonTable) InsertWithID(id string, data *Person) (PersonRow, error) {
	if t.q == nil {
		return PersonRow{}, errors.New("nil DBTX")
	}
	if data == nil {
		return PersonRow{}, errors.New("nil data")
	}
	return t.insertWithID(id, data)
}

func (t *PersonTable) insertWithID(id string, data *Person) (PersonRow, error) {
	if t.q == nil {
		return PersonRow{}, errors.New("nil DBTX")
	}
	if data == nil {
		return PersonRow{}, errors.New("nil data")
	}
	if id == "" {
		return PersonRow{}, errors.New("empty id")
	}
	if err := rt.ValidateUUID(id); err != nil {
		return PersonRow{}, fmt.Errorf("validate id %s: %w", id, err)
	}
	if err := data.Valid(); err != nil {
		return PersonRow{}, fmt.Errorf("validate Person: %w", err)
	}
	ctx := context.Background()
	atNs := rt.NowNs()
	dataBytes, err := proto.Marshal(data)
	if err != nil {
		return PersonRow{}, fmt.Errorf("marshal Person: %w", err)
	}
	if _, err := t.q.ExecContext(ctx, `DELETE FROM _deleted WHERE table_name = ? AND id = ?`, PersonTableName, id); err != nil {
		return PersonRow{}, fmt.Errorf("delete tombstone for %s/%s: %w", PersonTableName, id, err)
	}
	insertArgs := []any{id, atNs, dataBytes}
	insertArgs = append(insertArgs, data.GetName())
	insertArgs = append(insertArgs, data.GetAge())
	if _, err := t.q.ExecContext(ctx, PersonInsertSQL, insertArgs...); err != nil {
		return PersonRow{}, fmt.Errorf("insert into %s: %w", PersonTableName, err)
	}
	return PersonRow{ID: id, AtNs: atNs, Data: data}, nil
}

func (t *PersonTable) UpdateByID(id string, data *Person) (PersonRow, error) {
	if t.q == nil {
		return PersonRow{}, errors.New("nil DBTX")
	}
	if id == "" {
		return PersonRow{}, errors.New("empty id")
	}
	if err := rt.ValidateUUID(id); err != nil {
		return PersonRow{}, fmt.Errorf("validate id %s: %w", id, err)
	}
	if data == nil {
		return PersonRow{}, errors.New("nil data")
	}
	if err := data.Valid(); err != nil {
		return PersonRow{}, fmt.Errorf("validate Person: %w", err)
	}
	ctx := context.Background()
	atNs := rt.NowNs()
	dataBytes, err := proto.Marshal(data)
	if err != nil {
		return PersonRow{}, fmt.Errorf("marshal Person: %w", err)
	}
	if _, err := t.q.ExecContext(ctx, `DELETE FROM _deleted WHERE table_name = ? AND id = ?`, PersonTableName, id); err != nil {
		return PersonRow{}, fmt.Errorf("delete tombstone for %s/%s: %w", PersonTableName, id, err)
	}
	updateArgs := []any{id, atNs, dataBytes}
	updateArgs = append(updateArgs, data.GetName())
	updateArgs = append(updateArgs, data.GetAge())
	if _, err := t.q.ExecContext(ctx, PersonUpsertSQL, updateArgs...); err != nil {
		return PersonRow{}, fmt.Errorf("upsert into %s: %w", PersonTableName, err)
	}
	return PersonRow{ID: id, AtNs: atNs, Data: data}, nil
}

func (t *PersonTable) UpdateRow(row PersonRow) (PersonRow, error) {
	if t.q == nil {
		return PersonRow{}, errors.New("nil DBTX")
	}
	if row.ID == "" {
		return PersonRow{}, errors.New("empty id")
	}
	if row.Data == nil {
		return PersonRow{}, errors.New("nil data")
	}
	return t.UpdateByID(row.ID, row.Data)
}

func (t *PersonTable) DeleteByID(id string) error {
	if t.q == nil {
		return errors.New("nil DBTX")
	}
	if id == "" {
		return errors.New("empty id")
	}
	ctx := context.Background()
	atNs := rt.NowNs()
	if _, err := t.q.ExecContext(ctx, `INSERT INTO _deleted (table_name, id, at_ns) VALUES (?, ?, ?) ON CONFLICT(table_name, id) DO UPDATE SET at_ns = excluded.at_ns`, PersonTableName, id, atNs); err != nil {
		return fmt.Errorf("insert tombstone for %s/%s: %w", PersonTableName, id, err)
	}
	if _, err := t.q.ExecContext(ctx, `DELETE FROM "`+PersonTableName+`" WHERE id = ?`, id); err != nil {
		return fmt.Errorf("delete from %s/%s: %w", PersonTableName, id, err)
	}
	return nil
}

func (t *PersonTable) DeleteRow(row PersonRow) error {
	if t.q == nil {
		return errors.New("nil DBTX")
	}
	if row.ID == "" {
		return errors.New("empty id")
	}
	return t.DeleteByID(row.ID)
}

func (t *PersonTable) upsertWithAtNs(id string, atNs int64, data *Person) error {
	if t.q == nil {
		return errors.New("nil DBTX")
	}
	if id == "" {
		return errors.New("empty id")
	}
	if data == nil {
		return errors.New("nil data")
	}
	ctx := context.Background()
	dataBytes, err := proto.Marshal(data)
	if err != nil {
		return fmt.Errorf("marshal Person: %w", err)
	}
	if _, err := t.q.ExecContext(ctx, `DELETE FROM _deleted WHERE table_name = ? AND id = ?`, PersonTableName, id); err != nil {
		return fmt.Errorf("delete tombstone for %s/%s: %w", PersonTableName, id, err)
	}
	upsertArgs := []any{id, atNs, dataBytes}
	upsertArgs = append(upsertArgs, data.GetName())
	upsertArgs = append(upsertArgs, data.GetAge())
	if _, err := t.q.ExecContext(ctx, PersonUpsertSQL, upsertArgs...); err != nil {
		return fmt.Errorf("upsert into %s: %w", PersonTableName, err)
	}
	return nil
}

func (t *PersonTable) tombstoneWithAtNs(id string, atNs int64) error {
	if t.q == nil {
		return errors.New("nil DBTX")
	}
	if id == "" {
		return errors.New("empty id")
	}
	ctx := context.Background()
	if _, err := t.q.ExecContext(ctx, `INSERT INTO _deleted (table_name, id, at_ns) VALUES (?, ?, ?) ON CONFLICT(table_name, id) DO UPDATE SET at_ns = excluded.at_ns`, PersonTableName, id, atNs); err != nil {
		return fmt.Errorf("insert tombstone for %s/%s: %w", PersonTableName, id, err)
	}
	if _, err := t.q.ExecContext(ctx, `DELETE FROM "`+PersonTableName+`" WHERE id = ?`, id); err != nil {
		return fmt.Errorf("delete from %s/%s: %w", PersonTableName, id, err)
	}
	return nil
}

func (t *PersonTable) reproject() error {
	ctx := context.Background()
	rows, err := t.q.QueryContext(ctx, `SELECT id, data FROM "`+PersonTableName+`"`)
	if err != nil {
		return fmt.Errorf("query rows for reprojection: %w", err)
	}
	type reprojectRow struct {
		id        string
		dataBytes []byte
	}
	rowBuffer := make([]reprojectRow, 0)
	for rows.Next() {
		var id string
		var dataBytes []byte
		if err := rows.Scan(&id, &dataBytes); err != nil {
			return fmt.Errorf("scan reprojection row: %w", err)
		}
		copiedData := make([]byte, len(dataBytes))
		copy(copiedData, dataBytes)
		rowBuffer = append(rowBuffer, reprojectRow{id: id, dataBytes: copiedData})
	}
	if err := rows.Err(); err != nil {
		return fmt.Errorf("iterate reprojection rows: %w", err)
	}
	if err := rows.Close(); err != nil {
		return fmt.Errorf("close reprojection rows: %w", err)
	}
	for _, row := range rowBuffer {
		data := &Person{}
		if err := proto.Unmarshal(row.dataBytes, data); err != nil {
			return fmt.Errorf("unmarshal reprojection row: %w", err)
		}
		reprojectArgs := []any{}
		reprojectArgs = append(reprojectArgs, data.GetName())
		reprojectArgs = append(reprojectArgs, data.GetAge())
		reprojectArgs = append(reprojectArgs, row.id)
		if _, err := t.q.ExecContext(ctx, PersonReprojectSQL, reprojectArgs...); err != nil {
			return fmt.Errorf("reproject row %s: %w", row.id, err)
		}
	}
	return nil
}

func (t *PersonTable) drainUnknownRows(typeName string) error {
	if t.q == nil {
		return errors.New("nil DBTX")
	}
	if typeName == "" {
		return errors.New("empty type name")
	}
	return rt.ReplayUnknownByType(t.q, typeName, func(record proprdbJSONLRecord) error {
		if record.Deleted {
			return t.tombstoneWithAtNs(record.ID, record.AtNs)
		}
		anyMessage := &anypb.Any{}
		if err := protojson.Unmarshal(record.Data, anyMessage); err != nil {
			return fmt.Errorf("unmarshal unknown data for Person %s: %w", record.ID, err)
		}
		data := &Person{}
		if err := anypb.UnmarshalTo(anyMessage, data, proto.UnmarshalOptions{}); err != nil {
			return fmt.Errorf("unmarshal unknown payload for Person %s: %w", record.ID, err)
		}
		return t.upsertWithAtNs(record.ID, record.AtNs, data)
	})
}

func (t *PersonTable) DrainUnknownRows() error {
	return t.drainUnknownRows(PersonTypeName)
}

const NoteTableName = "generatedtest_example_note"
const NoteTypeName = "generatedtest.example.Note"
const NoteProjectionSchema = "text:string"
const NoteCreateTableSQL = "CREATE TABLE IF NOT EXISTS \"generatedtest_example_note\" (\"id\" TEXT PRIMARY KEY, \"at_ns\" INTEGER NOT NULL, \"data\" BLOB NOT NULL, \"text\" TEXT NOT NULL DEFAULT '')"
const NoteInsertSQL = "INSERT INTO \"generatedtest_example_note\" (\"id\", \"at_ns\", \"data\", \"text\") VALUES (?, ?, ?, ?)"
const NoteUpsertSQL = "INSERT INTO \"generatedtest_example_note\" (\"id\", \"at_ns\", \"data\", \"text\") VALUES (?, ?, ?, ?) ON CONFLICT(id) DO UPDATE SET \"at_ns\" = excluded.\"at_ns\", \"data\" = excluded.\"data\", \"text\" = excluded.\"text\""
const NoteGeneratedIndexPrefix = "idx_generatedtest_example_note__"
const NoteReprojectSQL = "UPDATE \"generatedtest_example_note\" SET \"text\" = ? WHERE id = ?"

type NoteRow struct {
	ID   string
	AtNs int64
	Data *Note
}

type NoteTable struct {
	q DBTX
}

func NewNoteTable(q DBTX) *NoteTable {
	return &NoteTable{q: q}
}

func (t *NoteTable) Init() error {
	if t.q == nil {
		return errors.New("nil DBTX")
	}
	if err := rt.EnsureCoreTables(t.q); err != nil {
		return err
	}
	ctx := context.Background()
	if _, err := t.q.ExecContext(ctx, NoteCreateTableSQL); err != nil {
		return fmt.Errorf("create table %s: %w", NoteTableName, err)
	}
	columnRows, err := t.q.QueryContext(ctx, `PRAGMA table_info("`+NoteTableName+`")`)
	if err != nil {
		return fmt.Errorf("read columns for %s: %w", NoteTableName, err)
	}
	existingColumns := make(map[string]bool)
	for columnRows.Next() {
		var cid int
		var name string
		var colType string
		var notNull int
		var defaultValue any
		var pk int
		if err := columnRows.Scan(&cid, &name, &colType, &notNull, &defaultValue, &pk); err != nil {
			if closeErr := rt.CloseRows(columnRows, "projection metadata"); closeErr != nil {
				return fmt.Errorf("scan pragma row: %w (additionally, %v)", err, closeErr)
			}
			return fmt.Errorf("scan pragma row: %w", err)
		}
		existingColumns[name] = true
	}
	if err := columnRows.Err(); err != nil {
		if closeErr := rt.CloseRows(columnRows, "projection metadata"); closeErr != nil {
			return fmt.Errorf("iterate pragma rows: %w (additionally, %v)", err, closeErr)
		}
		return fmt.Errorf("iterate pragma rows: %w", err)
	}
	if err := rt.CloseRows(columnRows, "projection metadata"); err != nil {
		return err
	}
	if !existingColumns["text"] {
		if _, err := t.q.ExecContext(ctx, `ALTER TABLE "`+NoteTableName+`" ADD COLUMN "text" TEXT NOT NULL DEFAULT ''`); err != nil {
			return fmt.Errorf("add projection column text to %s: %w", NoteTableName, err)
		}
	}
	if err := rt.EnsureManagedIndexes(t.q, NoteTableName, NoteGeneratedIndexPrefix, []string{}, []string{}); err != nil {
		return err
	}
	var currentSchema string
	schemaErr := t.q.QueryRowContext(ctx, `SELECT schema_hash FROM _proprdb_schema WHERE table_name = ?`, NoteTableName).Scan(&currentSchema)
	if errors.Is(schemaErr, sql.ErrNoRows) {
		if _, insertErr := t.q.ExecContext(ctx, `INSERT INTO _proprdb_schema (table_name, schema_hash) VALUES (?, ?)`, NoteTableName, NoteProjectionSchema); insertErr != nil {
			return fmt.Errorf("insert schema hash for %s: %w", NoteTableName, insertErr)
		}
	} else if schemaErr != nil {
		return fmt.Errorf("select schema hash for %s: %w", NoteTableName, schemaErr)
	} else if currentSchema != NoteProjectionSchema {
		if err := t.reproject(); err != nil {
			return fmt.Errorf("reproject table %s: %w", NoteTableName, err)
		}
		if _, err := t.q.ExecContext(ctx, `UPDATE _proprdb_schema SET schema_hash = ? WHERE table_name = ?`, NoteProjectionSchema, NoteTableName); err != nil {
			return fmt.Errorf("update schema hash for %s: %w", NoteTableName, err)
		}
	}
	if err := t.drainUnknownRows(NoteTypeName); err != nil {
		return fmt.Errorf("drain unknown rows for %s: %w", NoteTableName, err)
	}
	return nil
}

func (t *NoteTable) Select(where string, args ...any) ([]NoteRow, error) {
	if t.q == nil {
		return nil, errors.New("nil DBTX")
	}
	ctx := context.Background()
	query := `SELECT id, at_ns, data FROM "` + NoteTableName + `"`
	if strings.TrimSpace(where) != "" {
		query += " WHERE " + where
	}
	rows, err := t.q.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("select from %s: %w", NoteTableName, err)
	}
	result := make([]NoteRow, 0)
	for rows.Next() {
		var id string
		var atNs int64
		var dataBytes []byte
		if err := rows.Scan(&id, &atNs, &dataBytes); err != nil {
			if closeErr := rt.CloseRows(rows, "select"); closeErr != nil {
				return nil, fmt.Errorf("scan row from %s: %w (additionally, %v)", NoteTableName, err, closeErr)
			}
			return nil, fmt.Errorf("scan row from %s: %w", NoteTableName, err)
		}
		data := &Note{}
		if err := proto.Unmarshal(dataBytes, data); err != nil {
			if closeErr := rt.CloseRows(rows, "select"); closeErr != nil {
				return nil, fmt.Errorf("unmarshal Note row: %w (additionally, %v)", err, closeErr)
			}
			return nil, fmt.Errorf("unmarshal Note row: %w", err)
		}
		result = append(result, NoteRow{ID: id, AtNs: atNs, Data: data})
	}
	if err := rows.Err(); err != nil {
		if closeErr := rt.CloseRows(rows, "select"); closeErr != nil {
			return nil, fmt.Errorf("iterate rows from %s: %w (additionally, %v)", NoteTableName, err, closeErr)
		}
		return nil, fmt.Errorf("iterate rows from %s: %w", NoteTableName, err)
	}
	if err := rt.CloseRows(rows, "select"); err != nil {
		return nil, err
	}
	return result, nil
}

func (t *NoteTable) Insert(data *Note) (NoteRow, error) {
	if t.q == nil {
		return NoteRow{}, errors.New("nil DBTX")
	}
	if data == nil {
		return NoteRow{}, errors.New("nil data")
	}
	id, err := rt.UUIDv7()
	if err != nil {
		return NoteRow{}, fmt.Errorf("generate uuidv7: %w", err)
	}
	if err := rt.ValidateUUID(id); err != nil {
		return NoteRow{}, fmt.Errorf("validate generated id %s: %w", id, err)
	}
	return t.insertWithID(id, data)
}

func (t *NoteTable) insertWithID(id string, data *Note) (NoteRow, error) {
	if t.q == nil {
		return NoteRow{}, errors.New("nil DBTX")
	}
	if data == nil {
		return NoteRow{}, errors.New("nil data")
	}
	if id == "" {
		return NoteRow{}, errors.New("empty id")
	}
	if err := rt.ValidateUUID(id); err != nil {
		return NoteRow{}, fmt.Errorf("validate id %s: %w", id, err)
	}
	ctx := context.Background()
	atNs := rt.NowNs()
	dataBytes, err := proto.Marshal(data)
	if err != nil {
		return NoteRow{}, fmt.Errorf("marshal Note: %w", err)
	}
	if _, err := t.q.ExecContext(ctx, `DELETE FROM _deleted WHERE table_name = ? AND id = ?`, NoteTableName, id); err != nil {
		return NoteRow{}, fmt.Errorf("delete tombstone for %s/%s: %w", NoteTableName, id, err)
	}
	insertArgs := []any{id, atNs, dataBytes}
	insertArgs = append(insertArgs, data.GetText())
	if _, err := t.q.ExecContext(ctx, NoteInsertSQL, insertArgs...); err != nil {
		return NoteRow{}, fmt.Errorf("insert into %s: %w", NoteTableName, err)
	}
	return NoteRow{ID: id, AtNs: atNs, Data: data}, nil
}

func (t *NoteTable) UpdateByID(id string, data *Note) (NoteRow, error) {
	if t.q == nil {
		return NoteRow{}, errors.New("nil DBTX")
	}
	if id == "" {
		return NoteRow{}, errors.New("empty id")
	}
	if err := rt.ValidateUUID(id); err != nil {
		return NoteRow{}, fmt.Errorf("validate id %s: %w", id, err)
	}
	if data == nil {
		return NoteRow{}, errors.New("nil data")
	}
	ctx := context.Background()
	atNs := rt.NowNs()
	dataBytes, err := proto.Marshal(data)
	if err != nil {
		return NoteRow{}, fmt.Errorf("marshal Note: %w", err)
	}
	if _, err := t.q.ExecContext(ctx, `DELETE FROM _deleted WHERE table_name = ? AND id = ?`, NoteTableName, id); err != nil {
		return NoteRow{}, fmt.Errorf("delete tombstone for %s/%s: %w", NoteTableName, id, err)
	}
	updateArgs := []any{id, atNs, dataBytes}
	updateArgs = append(updateArgs, data.GetText())
	if _, err := t.q.ExecContext(ctx, NoteUpsertSQL, updateArgs...); err != nil {
		return NoteRow{}, fmt.Errorf("upsert into %s: %w", NoteTableName, err)
	}
	return NoteRow{ID: id, AtNs: atNs, Data: data}, nil
}

func (t *NoteTable) UpdateRow(row NoteRow) (NoteRow, error) {
	if t.q == nil {
		return NoteRow{}, errors.New("nil DBTX")
	}
	if row.ID == "" {
		return NoteRow{}, errors.New("empty id")
	}
	if row.Data == nil {
		return NoteRow{}, errors.New("nil data")
	}
	return t.UpdateByID(row.ID, row.Data)
}

func (t *NoteTable) DeleteByID(id string) error {
	if t.q == nil {
		return errors.New("nil DBTX")
	}
	if id == "" {
		return errors.New("empty id")
	}
	ctx := context.Background()
	atNs := rt.NowNs()
	if _, err := t.q.ExecContext(ctx, `INSERT INTO _deleted (table_name, id, at_ns) VALUES (?, ?, ?) ON CONFLICT(table_name, id) DO UPDATE SET at_ns = excluded.at_ns`, NoteTableName, id, atNs); err != nil {
		return fmt.Errorf("insert tombstone for %s/%s: %w", NoteTableName, id, err)
	}
	if _, err := t.q.ExecContext(ctx, `DELETE FROM "`+NoteTableName+`" WHERE id = ?`, id); err != nil {
		return fmt.Errorf("delete from %s/%s: %w", NoteTableName, id, err)
	}
	return nil
}

func (t *NoteTable) DeleteRow(row NoteRow) error {
	if t.q == nil {
		return errors.New("nil DBTX")
	}
	if row.ID == "" {
		return errors.New("empty id")
	}
	return t.DeleteByID(row.ID)
}

func (t *NoteTable) upsertWithAtNs(id string, atNs int64, data *Note) error {
	if t.q == nil {
		return errors.New("nil DBTX")
	}
	if id == "" {
		return errors.New("empty id")
	}
	if data == nil {
		return errors.New("nil data")
	}
	ctx := context.Background()
	dataBytes, err := proto.Marshal(data)
	if err != nil {
		return fmt.Errorf("marshal Note: %w", err)
	}
	if _, err := t.q.ExecContext(ctx, `DELETE FROM _deleted WHERE table_name = ? AND id = ?`, NoteTableName, id); err != nil {
		return fmt.Errorf("delete tombstone for %s/%s: %w", NoteTableName, id, err)
	}
	upsertArgs := []any{id, atNs, dataBytes}
	upsertArgs = append(upsertArgs, data.GetText())
	if _, err := t.q.ExecContext(ctx, NoteUpsertSQL, upsertArgs...); err != nil {
		return fmt.Errorf("upsert into %s: %w", NoteTableName, err)
	}
	return nil
}

func (t *NoteTable) tombstoneWithAtNs(id string, atNs int64) error {
	if t.q == nil {
		return errors.New("nil DBTX")
	}
	if id == "" {
		return errors.New("empty id")
	}
	ctx := context.Background()
	if _, err := t.q.ExecContext(ctx, `INSERT INTO _deleted (table_name, id, at_ns) VALUES (?, ?, ?) ON CONFLICT(table_name, id) DO UPDATE SET at_ns = excluded.at_ns`, NoteTableName, id, atNs); err != nil {
		return fmt.Errorf("insert tombstone for %s/%s: %w", NoteTableName, id, err)
	}
	if _, err := t.q.ExecContext(ctx, `DELETE FROM "`+NoteTableName+`" WHERE id = ?`, id); err != nil {
		return fmt.Errorf("delete from %s/%s: %w", NoteTableName, id, err)
	}
	return nil
}

func (t *NoteTable) reproject() error {
	ctx := context.Background()
	rows, err := t.q.QueryContext(ctx, `SELECT id, data FROM "`+NoteTableName+`"`)
	if err != nil {
		return fmt.Errorf("query rows for reprojection: %w", err)
	}
	type reprojectRow struct {
		id        string
		dataBytes []byte
	}
	rowBuffer := make([]reprojectRow, 0)
	for rows.Next() {
		var id string
		var dataBytes []byte
		if err := rows.Scan(&id, &dataBytes); err != nil {
			return fmt.Errorf("scan reprojection row: %w", err)
		}
		copiedData := make([]byte, len(dataBytes))
		copy(copiedData, dataBytes)
		rowBuffer = append(rowBuffer, reprojectRow{id: id, dataBytes: copiedData})
	}
	if err := rows.Err(); err != nil {
		return fmt.Errorf("iterate reprojection rows: %w", err)
	}
	if err := rows.Close(); err != nil {
		return fmt.Errorf("close reprojection rows: %w", err)
	}
	for _, row := range rowBuffer {
		data := &Note{}
		if err := proto.Unmarshal(row.dataBytes, data); err != nil {
			return fmt.Errorf("unmarshal reprojection row: %w", err)
		}
		reprojectArgs := []any{}
		reprojectArgs = append(reprojectArgs, data.GetText())
		reprojectArgs = append(reprojectArgs, row.id)
		if _, err := t.q.ExecContext(ctx, NoteReprojectSQL, reprojectArgs...); err != nil {
			return fmt.Errorf("reproject row %s: %w", row.id, err)
		}
	}
	return nil
}

func (t *NoteTable) drainUnknownRows(typeName string) error {
	if t.q == nil {
		return errors.New("nil DBTX")
	}
	if typeName == "" {
		return errors.New("empty type name")
	}
	return rt.ReplayUnknownByType(t.q, typeName, func(record proprdbJSONLRecord) error {
		if record.Deleted {
			return t.tombstoneWithAtNs(record.ID, record.AtNs)
		}
		anyMessage := &anypb.Any{}
		if err := protojson.Unmarshal(record.Data, anyMessage); err != nil {
			return fmt.Errorf("unmarshal unknown data for Note %s: %w", record.ID, err)
		}
		data := &Note{}
		if err := anypb.UnmarshalTo(anyMessage, data, proto.UnmarshalOptions{}); err != nil {
			return fmt.Errorf("unmarshal unknown payload for Note %s: %w", record.ID, err)
		}
		return t.upsertWithAtNs(record.ID, record.AtNs, data)
	})
}

func (t *NoteTable) DrainUnknownRows() error {
	return t.drainUnknownRows(NoteTypeName)
}

type CRUD struct {
	Person *PersonTable
	Note   *NoteTable
}

var crudGeneratedTableDescriptors = []rt.GeneratedTableDescriptor{
	{TableName: PersonTableName, TypeName: PersonTypeName, IsCore: false, SyncEnabled: true},
	{TableName: NoteTableName, TypeName: NoteTypeName, IsCore: false, SyncEnabled: false},
	{TableName: rt.CoreTableDeletedName, IsCore: true, SyncEnabled: false},
	{TableName: rt.CoreTableSyncName, IsCore: true, SyncEnabled: false},
	{TableName: rt.CoreTableSchemaStateName, IsCore: true, SyncEnabled: false},
	{TableName: rt.CoreTableUnknownName, IsCore: true, SyncEnabled: false},
}

func NewCRUD(q DBTX) *CRUD {
	return &CRUD{
		Person: NewPersonTable(q),
		Note:   NewNoteTable(q),
	}
}

func (c *CRUD) TableDescriptors() []rt.GeneratedTableDescriptor {
	copiedDescriptors := make([]rt.GeneratedTableDescriptor, len(crudGeneratedTableDescriptors))
	copy(copiedDescriptors, crudGeneratedTableDescriptors)
	return copiedDescriptors
}

func (c *CRUD) dbtx() (DBTX, error) {
	if c == nil {
		return nil, errors.New("nil CRUD")
	}
	if c.Person != nil && c.Person.q != nil {
		return c.Person.q, nil
	}
	if c.Note != nil && c.Note.q != nil {
		return c.Note.q, nil
	}
	return nil, errors.New("nil DBTX")
}

func (c *CRUD) Init() error {
	if err := c.Person.Init(); err != nil {
		return fmt.Errorf("init Person table: %w", err)
	}
	if err := c.Note.Init(); err != nil {
		return fmt.Errorf("init Note table: %w", err)
	}
	return nil
}

func (c *CRUD) WriteJSONL(remote string, w io.Writer) error {
	if w == nil {
		return errors.New("nil writer")
	}
	q, err := c.dbtx()
	if err != nil {
		return err
	}
	encoder := json.NewEncoder(w)
	personRows, err := c.Person.Select("")
	if err != nil {
		return fmt.Errorf("select Person rows for jsonl write: %w", err)
	}
	for _, row := range personRows {
		needsSend, err := rt.SyncNeedsSend(q, row.ID, PersonTableName, remote, row.AtNs)
		if err != nil {
			return err
		}
		if !needsSend {
			continue
		}
		dataJSON, err := rt.MarshalAnyJSON(row.Data)
		if err != nil {
			return fmt.Errorf("marshal Person %s for jsonl write: %w", row.ID, err)
		}
		record := proprdbJSONLRecord{ID: row.ID, AtNs: row.AtNs, Data: dataJSON}
		if err := encoder.Encode(record); err != nil {
			return fmt.Errorf("write jsonl row for Person %s: %w", row.ID, err)
		}
		if err := rt.SyncUpsert(q, row.ID, PersonTableName, remote, row.AtNs); err != nil {
			return err
		}
	}
	tombstoneRows, err := q.QueryContext(context.Background(), `SELECT table_name, id, at_ns FROM _deleted WHERE table_name IN (?)`, PersonTableName)
	if err != nil {
		return fmt.Errorf("select tombstones for jsonl write: %w", err)
	}
	for tombstoneRows.Next() {
		var tableName string
		var id string
		var atNs int64
		if err := tombstoneRows.Scan(&tableName, &id, &atNs); err != nil {
			if closeErr := rt.CloseRows(tombstoneRows, "tombstone sync"); closeErr != nil {
				return fmt.Errorf("scan tombstone row: %w (additionally, %v)", err, closeErr)
			}
			return fmt.Errorf("scan tombstone row: %w", err)
		}
		needsSend, err := rt.SyncNeedsSend(q, id, tableName, remote, atNs)
		if err != nil {
			return err
		}
		if !needsSend {
			continue
		}
		var typeName string
		switch tableName {
		case PersonTableName:
			typeName = PersonTypeName
		default:
			return fmt.Errorf("unsupported tombstone table %s", tableName)
		}
		dataJSON, err := rt.MarshalTypeOnlyAnyJSON(typeName)
		if err != nil {
			return fmt.Errorf("marshal tombstone %s/%s for jsonl write: %w", tableName, id, err)
		}
		record := proprdbJSONLRecord{ID: id, Deleted: true, AtNs: atNs, Data: dataJSON}
		if err := encoder.Encode(record); err != nil {
			return fmt.Errorf("write jsonl tombstone %s/%s: %w", tableName, id, err)
		}
		if err := rt.SyncUpsert(q, id, tableName, remote, atNs); err != nil {
			if closeErr := rt.CloseRows(tombstoneRows, "tombstone sync"); closeErr != nil {
				return fmt.Errorf("sync tombstone %s/%s: %w (additionally, %v)", tableName, id, err, closeErr)
			}
			return err
		}
	}
	if err := tombstoneRows.Err(); err != nil {
		if closeErr := rt.CloseRows(tombstoneRows, "tombstone sync"); closeErr != nil {
			return fmt.Errorf("iterate tombstone rows: %w (additionally, %v)", err, closeErr)
		}
		return fmt.Errorf("iterate tombstone rows: %w", err)
	}
	if err := rt.CloseRows(tombstoneRows, "tombstone sync"); err != nil {
		return err
	}
	return nil
}

func (c *CRUD) ReadJSONL(remote string, r io.Reader) error {
	if r == nil {
		return errors.New("nil reader")
	}
	q, err := c.dbtx()
	if err != nil {
		return err
	}
	readErr := rt.ReadJSONL(r, func(record proprdbJSONLRecord, lineNumber int) error {
		if record.ID == "" {
			return fmt.Errorf("jsonl line %d has empty id", lineNumber)
		}
		if len(record.Data) == 0 {
			return fmt.Errorf("jsonl line %d has empty data", lineNumber)
		}
		typeName, err := rt.TypeNameFromAnyJSON(record.Data)
		if err != nil {
			return fmt.Errorf("read @type on line %d: %w", lineNumber, err)
		}
		switch typeName {
		case PersonTypeName:
			localMaxAtNs, err := rt.LocalMaxAtNs(q, PersonTableName, record.ID)
			if err != nil {
				return err
			}
			if err := rt.SyncUpsert(q, record.ID, PersonTableName, remote, record.AtNs); err != nil {
				return err
			}
			if record.AtNs < localMaxAtNs {
				return nil
			}
			if record.Deleted {
				if c.Person == nil {
					return errors.New("nil Person table")
				}
				return c.Person.tombstoneWithAtNs(record.ID, record.AtNs)
			}
			if c.Person == nil {
				return errors.New("nil Person table")
			}
			anyMessage := &anypb.Any{}
			if err := protojson.Unmarshal(record.Data, anyMessage); err != nil {
				return fmt.Errorf("unmarshal jsonl data on line %d: %w", lineNumber, err)
			}
			data := &Person{}
			if err := anypb.UnmarshalTo(anyMessage, data, proto.UnmarshalOptions{}); err != nil {
				return fmt.Errorf("unmarshal Person data on line %d: %w", lineNumber, err)
			}
			return c.Person.upsertWithAtNs(record.ID, record.AtNs, data)
		case NoteTypeName:
			slog.Error("ignoring unsynced jsonl record", "type", typeName, "id", record.ID, "remote", remote, "line", lineNumber)
			return nil
		default:
			return rt.UnknownInsert(q, typeName, record)
		}
	})
	compactErr := rt.CompactUnknownLatest(q)
	if readErr != nil {
		if compactErr != nil {
			return fmt.Errorf("read jsonl: %w (additionally, compact unknown rows: %v)", readErr, compactErr)
		}
		return readErr
	}
	if compactErr != nil {
		return fmt.Errorf("compact unknown rows: %w", compactErr)
	}
	return nil
}

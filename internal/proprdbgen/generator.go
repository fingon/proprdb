package proprdbgen

import (
	"errors"
	"fmt"
	"strconv"
	"strings"

	proprdbpb "github.com/fingon/proprdb/proto/proprdb"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	descriptorpb "google.golang.org/protobuf/types/descriptorpb"
)

type projectedField struct {
	ColumnName      string
	GetterName      string
	SQLiteType      string
	SQLiteDefault   string
	SchemaSignature string
}

type messageModel struct {
	GoName           string
	TableName        string
	TableTypeName    string
	RowTypeName      string
	ProjectionSchema string
	ProjectedFields  []projectedField
}

// GenerateFile generates proprdb CRUD code for one .proto file.
func GenerateFile(plugin *protogen.Plugin, file *protogen.File) error {
	models, err := collectModels(file)
	if err != nil {
		return err
	}

	if len(models) == 0 {
		return nil
	}

	filename := file.GeneratedFilenamePrefix + ".proprdb.pb.go"
	g := plugin.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-proprdb. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	g.P("import (")
	g.P(`"context"`)
	g.P(`"crypto/rand"`)
	g.P(`"database/sql"`)
	g.P(`"encoding/binary"`)
	g.P(`"errors"`)
	g.P(`"fmt"`)
	g.P(`"strings"`)
	g.P(`"time"`)
	g.P()
	g.P(`"google.golang.org/protobuf/proto"`)
	g.P(")")
	g.P()

	emitShared(g)
	for _, model := range models {
		emitModel(g, model)
	}
	emitWrapper(g, models)

	return nil
}

func collectModels(file *protogen.File) ([]messageModel, error) {
	models := make([]messageModel, 0)
	for _, message := range file.Messages {
		if err := appendMessageModels(&models, message); err != nil {
			return nil, err
		}
	}

	return models, nil
}

func appendMessageModels(models *[]messageModel, message *protogen.Message) error {
	if !message.Desc.IsMapEntry() {
		model, err := buildModel(message)
		if err != nil {
			return err
		}

		*models = append(*models, model)
	}

	for _, nested := range message.Messages {
		if err := appendMessageModels(models, nested); err != nil {
			return err
		}
	}

	return nil
}

func buildModel(message *protogen.Message) (messageModel, error) {
	projected := make([]projectedField, 0)
	signatures := make([]string, 0)

	for _, field := range message.Fields {
		external, err := fieldExternal(field)
		if err != nil {
			return messageModel{}, fmt.Errorf("field %s: %w", field.Desc.FullName(), err)
		}

		if !external {
			continue
		}

		projection, err := projectedFieldFromProto(field)
		if err != nil {
			return messageModel{}, fmt.Errorf("field %s: %w", field.Desc.FullName(), err)
		}

		projected = append(projected, projection)
		signatures = append(signatures, projection.SchemaSignature)
	}

	return messageModel{
		GoName:           message.GoIdent.GoName,
		TableName:        tableNameForMessage(message),
		TableTypeName:    message.GoIdent.GoName + "Table",
		RowTypeName:      message.GoIdent.GoName + "Row",
		ProjectionSchema: strings.Join(signatures, ";"),
		ProjectedFields:  projected,
	}, nil
}

func fieldExternal(field *protogen.Field) (bool, error) {
	fieldOptions, ok := field.Desc.Options().(*descriptorpb.FieldOptions)
	if !ok || fieldOptions == nil {
		return false, nil
	}

	if !proto.HasExtension(fieldOptions, proprdbpb.E_External) {
		return false, nil
	}

	value := proto.GetExtension(fieldOptions, proprdbpb.E_External)

	switch external := value.(type) {
	case bool:
		return external, nil
	case *bool:
		if external == nil {
			return false, nil
		}

		return *external, nil
	default:
		return false, fmt.Errorf("unexpected proprdb.external type %T", value)
	}
}

func projectedFieldFromProto(field *protogen.Field) (projectedField, error) {
	if field.Desc.IsList() || field.Desc.IsMap() {
		return projectedField{}, errors.New("external field must be scalar")
	}

	columnName := string(field.Desc.Name())
	getterName := "Get" + field.GoName
	signature := fmt.Sprintf("%s:%s", columnName, field.Desc.Kind())

	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		return projectedField{columnName, getterName, "INTEGER", "0", signature}, nil
	case protoreflect.Int32Kind,
		protoreflect.Sint32Kind,
		protoreflect.Sfixed32Kind,
		protoreflect.Int64Kind,
		protoreflect.Sint64Kind,
		protoreflect.Sfixed64Kind,
		protoreflect.Uint32Kind,
		protoreflect.Fixed32Kind,
		protoreflect.Uint64Kind,
		protoreflect.Fixed64Kind,
		protoreflect.EnumKind:
		return projectedField{columnName, getterName, "INTEGER", "0", signature}, nil
	case protoreflect.FloatKind, protoreflect.DoubleKind:
		return projectedField{columnName, getterName, "REAL", "0", signature}, nil
	case protoreflect.StringKind:
		return projectedField{columnName, getterName, "TEXT", "''", signature}, nil
	case protoreflect.BytesKind:
		return projectedField{columnName, getterName, "BLOB", "X''", signature}, nil
	default:
		return projectedField{}, fmt.Errorf("unsupported external field kind %s", field.Desc.Kind())
	}
}

func tableNameForMessage(message *protogen.Message) string {
	fullName := strings.ReplaceAll(string(message.Desc.FullName()), ".", "_")
	return strings.ToLower(fullName)
}

func emitShared(g *protogen.GeneratedFile) {
	g.P("type DBTX interface {")
	g.P("\tExecContext(context.Context, string, ...any) (sql.Result, error)")
	g.P("\tQueryContext(context.Context, string, ...any) (*sql.Rows, error)")
	g.P("\tQueryRowContext(context.Context, string, ...any) *sql.Row")
	g.P("}")
	g.P()
	g.P("func proprdbNowNs() int64 {")
	g.P("\treturn time.Now().UnixNano()")
	g.P("}")
	g.P()
	g.P("func proprdbUUIDv7() (string, error) {")
	g.P("\tvar uuidBytes [16]byte")
	g.P("\tif _, err := rand.Read(uuidBytes[:]); err != nil {")
	g.P("\t\treturn \"\", fmt.Errorf(\"generate random bytes for uuidv7: %w\", err)")
	g.P("\t}")
	g.P("\tmilliseconds := uint64(time.Now().UnixMilli())")
	g.P("\tuuidBytes[0] = byte(milliseconds >> 40)")
	g.P("\tuuidBytes[1] = byte(milliseconds >> 32)")
	g.P("\tuuidBytes[2] = byte(milliseconds >> 24)")
	g.P("\tuuidBytes[3] = byte(milliseconds >> 16)")
	g.P("\tuuidBytes[4] = byte(milliseconds >> 8)")
	g.P("\tuuidBytes[5] = byte(milliseconds)")
	g.P("\tuuidBytes[6] = (uuidBytes[6] & 0x0f) | 0x70")
	g.P("\tuuidBytes[8] = (uuidBytes[8] & 0x3f) | 0x80")
	g.P("\tsegment1 := binary.BigEndian.Uint32(uuidBytes[0:4])")
	g.P("\tsegment2 := binary.BigEndian.Uint16(uuidBytes[4:6])")
	g.P("\tsegment3 := binary.BigEndian.Uint16(uuidBytes[6:8])")
	g.P("\tsegment4 := binary.BigEndian.Uint16(uuidBytes[8:10])")
	g.P("\tsegment5High := binary.BigEndian.Uint16(uuidBytes[10:12])")
	g.P("\tsegment5Low := binary.BigEndian.Uint32(uuidBytes[12:16])")
	g.P("\tsegment5 := (uint64(segment5High) << 32) | uint64(segment5Low)")
	g.P("\treturn fmt.Sprintf(\"%08x-%04x-%04x-%04x-%012x\", segment1, segment2, segment3, segment4, segment5), nil")
	g.P("}")
	g.P()
}

func emitModel(g *protogen.GeneratedFile, model messageModel) {
	tableNameConst := model.GoName + "TableName"
	schemaConst := model.GoName + "ProjectionSchema"
	createTableConst := model.GoName + "CreateTableSQL"
	insertConst := model.GoName + "InsertSQL"
	upsertConst := model.GoName + "UpsertSQL"
	reprojectConst := model.GoName + "ReprojectSQL"

	g.P("const ", tableNameConst, " = ", strconv.Quote(model.TableName))
	g.P("const ", schemaConst, " = ", strconv.Quote(model.ProjectionSchema))
	g.P("const ", createTableConst, " = ", strconv.Quote(createTableSQL(model)))
	g.P("const ", insertConst, " = ", strconv.Quote(insertSQL(model, false)))
	g.P("const ", upsertConst, " = ", strconv.Quote(insertSQL(model, true)))
	if len(model.ProjectedFields) > 0 {
		g.P("const ", reprojectConst, " = ", strconv.Quote(reprojectSQL(model)))
	}
	g.P()

	g.P("type ", model.RowTypeName, " struct {")
	g.P("\tID string")
	g.P("\tAtNs int64")
	g.P("\tData *", model.GoName)
	g.P("}")
	g.P()

	g.P("type ", model.TableTypeName, " struct {")
	g.P("\tq DBTX")
	g.P("}")
	g.P()

	g.P("func New", model.TableTypeName, "(q DBTX) *", model.TableTypeName, " {")
	g.P("\treturn &", model.TableTypeName, "{q: q}")
	g.P("}")
	g.P()

	emitInitMethod(g, model, tableNameConst, schemaConst, createTableConst)
	emitSelectMethod(g, model, tableNameConst)
	emitInsertMethod(g, model, tableNameConst, insertConst)
	emitUpdateMethod(g, model, tableNameConst, upsertConst)
	emitDeleteMethod(g, model, tableNameConst)
	if len(model.ProjectedFields) > 0 {
		emitReprojectMethod(g, model, tableNameConst, reprojectConst)
	}
}

func emitInitMethod(g *protogen.GeneratedFile, model messageModel, tableNameConst, schemaConst, createTableConst string) {
	g.P("func (t *", model.TableTypeName, ") Init() error {")
	g.P("\tif t.q == nil {")
	g.P("\t\treturn errors.New(\"nil DBTX\")")
	g.P("\t}")
	g.P("\tctx := context.Background()")
	g.P("\tif _, err := t.q.ExecContext(ctx, `CREATE TABLE IF NOT EXISTS _deleted (table_name TEXT NOT NULL, id TEXT NOT NULL, at_ns INTEGER NOT NULL, PRIMARY KEY (table_name, id))`); err != nil {")
	g.P("\t\treturn fmt.Errorf(\"create _deleted table: %w\", err)")
	g.P("\t}")
	g.P("\tif _, err := t.q.ExecContext(ctx, `CREATE TABLE IF NOT EXISTS _proprdb_schema (table_name TEXT PRIMARY KEY, schema_hash TEXT NOT NULL)`); err != nil {")
	g.P("\t\treturn fmt.Errorf(\"create _proprdb_schema table: %w\", err)")
	g.P("\t}")
	g.P("\tif _, err := t.q.ExecContext(ctx, ", createTableConst, "); err != nil {")
	g.P("\t\treturn fmt.Errorf(\"create table %s: %w\", ", tableNameConst, ", err)")
	g.P("\t}")

	if len(model.ProjectedFields) > 0 {
		g.P("\tcolumnRows, err := t.q.QueryContext(ctx, `PRAGMA table_info(\"`+", tableNameConst, "+`\")`)")
		g.P("\tif err != nil {")
		g.P("\t\treturn fmt.Errorf(\"read columns for %s: %w\", ", tableNameConst, ", err)")
		g.P("\t}")
		g.P("\tdefer func() { _ = columnRows.Close() }()")
		g.P("\texistingColumns := make(map[string]bool)")
		g.P("\tfor columnRows.Next() {")
		g.P("\t\tvar cid int")
		g.P("\t\tvar name string")
		g.P("\t\tvar colType string")
		g.P("\t\tvar notNull int")
		g.P("\t\tvar defaultValue any")
		g.P("\t\tvar pk int")
		g.P("\t\tif err := columnRows.Scan(&cid, &name, &colType, &notNull, &defaultValue, &pk); err != nil {")
		g.P("\t\t\treturn fmt.Errorf(\"scan pragma row: %w\", err)")
		g.P("\t\t}")
		g.P("\t\texistingColumns[name] = true")
		g.P("\t}")
		g.P("\tif err := columnRows.Err(); err != nil {")
		g.P("\t\treturn fmt.Errorf(\"iterate pragma rows: %w\", err)")
		g.P("\t}")
		for _, projectedField := range model.ProjectedFields {
			g.P("\tif !existingColumns[", strconv.Quote(projectedField.ColumnName), "] {")
			g.P("\t\tif _, err := t.q.ExecContext(ctx, `ALTER TABLE \"`+", tableNameConst, "+`\" ADD COLUMN \"", projectedField.ColumnName, "\" ", projectedField.SQLiteType, " NOT NULL DEFAULT ", projectedField.SQLiteDefault, "`); err != nil {")
			g.P("\t\t\treturn fmt.Errorf(\"add projection column ", projectedField.ColumnName, " to %s: %w\", ", tableNameConst, ", err)")
			g.P("\t\t}")
			g.P("\t}")
		}
	}

	g.P("\tvar currentSchema string")
	g.P("\tschemaErr := t.q.QueryRowContext(ctx, `SELECT schema_hash FROM _proprdb_schema WHERE table_name = ?`, ", tableNameConst, ").Scan(&currentSchema)")
	g.P("\tif errors.Is(schemaErr, sql.ErrNoRows) {")
	g.P("\t\tif _, insertErr := t.q.ExecContext(ctx, `INSERT INTO _proprdb_schema (table_name, schema_hash) VALUES (?, ?)`, ", tableNameConst, ", ", schemaConst, "); insertErr != nil {")
	g.P("\t\t\treturn fmt.Errorf(\"insert schema hash for %s: %w\", ", tableNameConst, ", insertErr)")
	g.P("\t\t}")
	g.P("\t\treturn nil")
	g.P("\t}")
	g.P("\tif schemaErr != nil {")
	g.P("\t\treturn fmt.Errorf(\"select schema hash for %s: %w\", ", tableNameConst, ", schemaErr)")
	g.P("\t}")
	g.P("\tif currentSchema == ", schemaConst, " {")
	g.P("\t\treturn nil")
	g.P("\t}")
	if len(model.ProjectedFields) > 0 {
		g.P("\tif err := t.reproject(); err != nil {")
		g.P("\t\treturn fmt.Errorf(\"reproject table %s: %w\", ", tableNameConst, ", err)")
		g.P("\t}")
	}
	g.P("\tif _, err := t.q.ExecContext(ctx, `UPDATE _proprdb_schema SET schema_hash = ? WHERE table_name = ?`, ", schemaConst, ", ", tableNameConst, "); err != nil {")
	g.P("\t\treturn fmt.Errorf(\"update schema hash for %s: %w\", ", tableNameConst, ", err)")
	g.P("\t}")
	g.P("\treturn nil")
	g.P("}")
	g.P()
}

func emitSelectMethod(g *protogen.GeneratedFile, model messageModel, tableNameConst string) {
	g.P("func (t *", model.TableTypeName, ") Select(where string, args ...any) ([]", model.RowTypeName, ", error) {")
	g.P("\tif t.q == nil {")
	g.P("\t\treturn nil, errors.New(\"nil DBTX\")")
	g.P("\t}")
	g.P("\tctx := context.Background()")
	g.P("\tquery := `SELECT id, at_ns, data FROM \"`+", tableNameConst, "+`\"`")
	g.P("\tif strings.TrimSpace(where) != \"\" {")
	g.P("\t\tquery += \" WHERE \" + where")
	g.P("\t}")
	g.P("\trows, err := t.q.QueryContext(ctx, query, args...)")
	g.P("\tif err != nil {")
	g.P("\t\treturn nil, fmt.Errorf(\"select from %s: %w\", ", tableNameConst, ", err)")
	g.P("\t}")
	g.P("\tdefer func() { _ = rows.Close() }()")
	g.P("\tresult := make([]", model.RowTypeName, ", 0)")
	g.P("\tfor rows.Next() {")
	g.P("\t\tvar id string")
	g.P("\t\tvar atNs int64")
	g.P("\t\tvar dataBytes []byte")
	g.P("\t\tif err := rows.Scan(&id, &atNs, &dataBytes); err != nil {")
	g.P("\t\t\treturn nil, fmt.Errorf(\"scan row from %s: %w\", ", tableNameConst, ", err)")
	g.P("\t\t}")
	g.P("\t\tdata := &", model.GoName, "{}")
	g.P("\t\tif err := proto.Unmarshal(dataBytes, data); err != nil {")
	g.P("\t\t\treturn nil, fmt.Errorf(\"unmarshal ", model.GoName, " row: %w\", err)")
	g.P("\t\t}")
	g.P("\t\tresult = append(result, ", model.RowTypeName, "{ID: id, AtNs: atNs, Data: data})")
	g.P("\t}")
	g.P("\tif err := rows.Err(); err != nil {")
	g.P("\t\treturn nil, fmt.Errorf(\"iterate rows from %s: %w\", ", tableNameConst, ", err)")
	g.P("\t}")
	g.P("\treturn result, nil")
	g.P("}")
	g.P()
}

func emitInsertMethod(g *protogen.GeneratedFile, model messageModel, tableNameConst, insertConst string) {
	g.P("func (t *", model.TableTypeName, ") Insert(data *", model.GoName, ") (", model.RowTypeName, ", error) {")
	g.P("\tif t.q == nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, errors.New(\"nil DBTX\")")
	g.P("\t}")
	g.P("\tif data == nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, errors.New(\"nil data\")")
	g.P("\t}")
	g.P("\tctx := context.Background()")
	g.P("\tid, err := proprdbUUIDv7()")
	g.P("\tif err != nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, fmt.Errorf(\"generate uuidv7: %w\", err)")
	g.P("\t}")
	g.P("\tatNs := proprdbNowNs()")
	g.P("\tdataBytes, err := proto.Marshal(data)")
	g.P("\tif err != nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, fmt.Errorf(\"marshal ", model.GoName, ": %w\", err)")
	g.P("\t}")
	g.P("\tif _, err := t.q.ExecContext(ctx, `DELETE FROM _deleted WHERE table_name = ? AND id = ?`, ", tableNameConst, ", id); err != nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, fmt.Errorf(\"delete tombstone for %s/%s: %w\", ", tableNameConst, ", id, err)")
	g.P("\t}")
	g.P("\tinsertArgs := []any{id, atNs, dataBytes}")
	for _, projectedField := range model.ProjectedFields {
		g.P("\tinsertArgs = append(insertArgs, data.", projectedField.GetterName, "())")
	}
	g.P("\tif _, err := t.q.ExecContext(ctx, ", insertConst, ", insertArgs...); err != nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, fmt.Errorf(\"insert into %s: %w\", ", tableNameConst, ", err)")
	g.P("\t}")
	g.P("\treturn ", model.RowTypeName, "{ID: id, AtNs: atNs, Data: data}, nil")
	g.P("}")
	g.P()
}

func emitUpdateMethod(g *protogen.GeneratedFile, model messageModel, tableNameConst, upsertConst string) {
	g.P("func (t *", model.TableTypeName, ") UpdateByID(id string, data *", model.GoName, ") (", model.RowTypeName, ", error) {")
	g.P("\tif t.q == nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, errors.New(\"nil DBTX\")")
	g.P("\t}")
	g.P("\tif id == \"\" {")
	g.P("\t\treturn ", model.RowTypeName, "{}, errors.New(\"empty id\")")
	g.P("\t}")
	g.P("\tif data == nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, errors.New(\"nil data\")")
	g.P("\t}")
	g.P("\tctx := context.Background()")
	g.P("\tatNs := proprdbNowNs()")
	g.P("\tdataBytes, err := proto.Marshal(data)")
	g.P("\tif err != nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, fmt.Errorf(\"marshal ", model.GoName, ": %w\", err)")
	g.P("\t}")
	g.P("\tif _, err := t.q.ExecContext(ctx, `DELETE FROM _deleted WHERE table_name = ? AND id = ?`, ", tableNameConst, ", id); err != nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, fmt.Errorf(\"delete tombstone for %s/%s: %w\", ", tableNameConst, ", id, err)")
	g.P("\t}")
	g.P("\tupdateArgs := []any{id, atNs, dataBytes}")
	for _, projectedField := range model.ProjectedFields {
		g.P("\tupdateArgs = append(updateArgs, data.", projectedField.GetterName, "())")
	}
	g.P("\tif _, err := t.q.ExecContext(ctx, ", upsertConst, ", updateArgs...); err != nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, fmt.Errorf(\"upsert into %s: %w\", ", tableNameConst, ", err)")
	g.P("\t}")
	g.P("\treturn ", model.RowTypeName, "{ID: id, AtNs: atNs, Data: data}, nil")
	g.P("}")
	g.P()

	g.P("func (t *", model.TableTypeName, ") UpdateRow(row ", model.RowTypeName, ") (", model.RowTypeName, ", error) {")
	g.P("\tif t.q == nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, errors.New(\"nil DBTX\")")
	g.P("\t}")
	g.P("\tif row.ID == \"\" {")
	g.P("\t\treturn ", model.RowTypeName, "{}, errors.New(\"empty id\")")
	g.P("\t}")
	g.P("\tif row.Data == nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, errors.New(\"nil data\")")
	g.P("\t}")
	g.P("\treturn t.UpdateByID(row.ID, row.Data)")
	g.P("}")
	g.P()
}

func emitDeleteMethod(g *protogen.GeneratedFile, model messageModel, tableNameConst string) {
	g.P("func (t *", model.TableTypeName, ") DeleteByID(id string) error {")
	g.P("\tif t.q == nil {")
	g.P("\t\treturn errors.New(\"nil DBTX\")")
	g.P("\t}")
	g.P("\tif id == \"\" {")
	g.P("\t\treturn errors.New(\"empty id\")")
	g.P("\t}")
	g.P("\tctx := context.Background()")
	g.P("\tatNs := proprdbNowNs()")
	g.P("\tif _, err := t.q.ExecContext(ctx, `INSERT INTO _deleted (table_name, id, at_ns) VALUES (?, ?, ?) ON CONFLICT(table_name, id) DO UPDATE SET at_ns = excluded.at_ns`, ", tableNameConst, ", id, atNs); err != nil {")
	g.P("\t\treturn fmt.Errorf(\"insert tombstone for %s/%s: %w\", ", tableNameConst, ", id, err)")
	g.P("\t}")
	g.P("\tif _, err := t.q.ExecContext(ctx, `DELETE FROM \"`+", tableNameConst, "+`\" WHERE id = ?`, id); err != nil {")
	g.P("\t\treturn fmt.Errorf(\"delete from %s/%s: %w\", ", tableNameConst, ", id, err)")
	g.P("\t}")
	g.P("\treturn nil")
	g.P("}")
	g.P()

	g.P("func (t *", model.TableTypeName, ") DeleteRow(row ", model.RowTypeName, ") error {")
	g.P("\tif t.q == nil {")
	g.P("\t\treturn errors.New(\"nil DBTX\")")
	g.P("\t}")
	g.P("\tif row.ID == \"\" {")
	g.P("\t\treturn errors.New(\"empty id\")")
	g.P("\t}")
	g.P("\treturn t.DeleteByID(row.ID)")
	g.P("}")
	g.P()
}

func emitReprojectMethod(g *protogen.GeneratedFile, model messageModel, tableNameConst, reprojectConst string) {
	g.P("func (t *", model.TableTypeName, ") reproject() error {")
	g.P("\tctx := context.Background()")
	g.P("\trows, err := t.q.QueryContext(ctx, `SELECT id, data FROM \"`+", tableNameConst, "+`\"`)")
	g.P("\tif err != nil {")
	g.P("\t\treturn fmt.Errorf(\"query rows for reprojection: %w\", err)")
	g.P("\t}")
	g.P("\ttype reprojectRow struct {")
	g.P("\t\tid string")
	g.P("\t\tdataBytes []byte")
	g.P("\t}")
	g.P("\trowBuffer := make([]reprojectRow, 0)")
	g.P("\tfor rows.Next() {")
	g.P("\t\tvar id string")
	g.P("\t\tvar dataBytes []byte")
	g.P("\t\tif err := rows.Scan(&id, &dataBytes); err != nil {")
	g.P("\t\t\treturn fmt.Errorf(\"scan reprojection row: %w\", err)")
	g.P("\t\t}")
	g.P("\t\tcopiedData := make([]byte, len(dataBytes))")
	g.P("\t\tcopy(copiedData, dataBytes)")
	g.P("\t\trowBuffer = append(rowBuffer, reprojectRow{id: id, dataBytes: copiedData})")
	g.P("\t}")
	g.P("\tif err := rows.Err(); err != nil {")
	g.P("\t\treturn fmt.Errorf(\"iterate reprojection rows: %w\", err)")
	g.P("\t}")
	g.P("\tif err := rows.Close(); err != nil {")
	g.P("\t\treturn fmt.Errorf(\"close reprojection rows: %w\", err)")
	g.P("\t}")
	g.P("\tfor _, row := range rowBuffer {")
	g.P("\t\tdata := &", model.GoName, "{}")
	g.P("\t\tif err := proto.Unmarshal(row.dataBytes, data); err != nil {")
	g.P("\t\t\treturn fmt.Errorf(\"unmarshal reprojection row: %w\", err)")
	g.P("\t\t}")
	g.P("\t\treprojectArgs := []any{}")
	for _, projectedField := range model.ProjectedFields {
		g.P("\t\treprojectArgs = append(reprojectArgs, data.", projectedField.GetterName, "())")
	}
	g.P("\t\treprojectArgs = append(reprojectArgs, row.id)")
	g.P("\t\tif _, err := t.q.ExecContext(ctx, ", reprojectConst, ", reprojectArgs...); err != nil {")
	g.P("\t\t\treturn fmt.Errorf(\"reproject row %s: %w\", row.id, err)")
	g.P("\t\t}")
	g.P("\t}")
	g.P("\treturn nil")
	g.P("}")
	g.P()
}

func emitWrapper(g *protogen.GeneratedFile, models []messageModel) {
	g.P("type CRUD struct {")
	for _, model := range models {
		g.P("\t", model.GoName, " *", model.TableTypeName)
	}
	g.P("}")
	g.P()
	g.P("func NewCRUD(q DBTX) *CRUD {")
	g.P("\treturn &CRUD{")
	for _, model := range models {
		g.P("\t\t", model.GoName, ": New", model.TableTypeName, "(q),")
	}
	g.P("\t}")
	g.P("}")
	g.P()
	g.P("func (c *CRUD) Init() error {")
	for _, model := range models {
		g.P("\tif err := c.", model.GoName, ".Init(); err != nil {")
		g.P("\t\treturn fmt.Errorf(\"init ", model.GoName, " table: %w\", err)")
		g.P("\t}")
	}
	g.P("\treturn nil")
	g.P("}")
	g.P()
}

func createTableSQL(model messageModel) string {
	columns := []string{`"id" TEXT PRIMARY KEY`, `"at_ns" INTEGER NOT NULL`, `"data" BLOB NOT NULL`}
	for _, projectedField := range model.ProjectedFields {
		columns = append(
			columns,
			fmt.Sprintf(
				`"%s" %s NOT NULL DEFAULT %s`,
				projectedField.ColumnName,
				projectedField.SQLiteType,
				projectedField.SQLiteDefault,
			),
		)
	}

	return fmt.Sprintf(
		`CREATE TABLE IF NOT EXISTS "%s" (%s)`,
		model.TableName,
		strings.Join(columns, ", "),
	)
}

func insertSQL(model messageModel, upsert bool) string {
	columns := []string{"id", "at_ns", "data"}
	for _, projectedField := range model.ProjectedFields {
		columns = append(columns, projectedField.ColumnName)
	}

	quotedColumns := make([]string, 0, len(columns))
	for _, column := range columns {
		quotedColumns = append(quotedColumns, fmt.Sprintf(`"%s"`, column))
	}

	placeholders := make([]string, 0, len(columns))
	for range columns {
		placeholders = append(placeholders, "?")
	}

	statement := fmt.Sprintf(
		`INSERT INTO "%s" (%s) VALUES (%s)`,
		model.TableName,
		strings.Join(quotedColumns, ", "),
		strings.Join(placeholders, ", "),
	)
	if !upsert {
		return statement
	}

	updates := []string{`"at_ns" = excluded."at_ns"`, `"data" = excluded."data"`}
	for _, projectedField := range model.ProjectedFields {
		updates = append(
			updates,
			fmt.Sprintf(
				`"%s" = excluded."%s"`,
				projectedField.ColumnName,
				projectedField.ColumnName,
			),
		)
	}

	return statement + " ON CONFLICT(id) DO UPDATE SET " + strings.Join(updates, ", ")
}

func reprojectSQL(model messageModel) string {
	updates := make([]string, 0, len(model.ProjectedFields))
	for _, projectedField := range model.ProjectedFields {
		updates = append(updates, fmt.Sprintf(`"%s" = ?`, projectedField.ColumnName))
	}

	return fmt.Sprintf(
		`UPDATE "%s" SET %s WHERE id = ?`,
		model.TableName,
		strings.Join(updates, ", "),
	)
}

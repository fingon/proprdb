package proprdbgen

import (
	"errors"
	"fmt"
	"strconv"
	"strings"

	proprdbpb "github.com/fingon/proprdb/proto/proprdb"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	descriptorpb "google.golang.org/protobuf/types/descriptorpb"
)

type projectedField struct {
	ColumnName      string
	GetterName      string
	SQLiteType      string
	SQLiteDefault   string
	SchemaSignature string
}

type messageModel struct {
	GoName           string
	TableName        string
	TypeName         string
	TableTypeName    string
	RowTypeName      string
	ProjectionSchema string
	ProjectedFields  []projectedField
	OmitSync         bool
	ValidateWrite    bool
}

// GenerateFile generates proprdb CRUD code for one .proto file.
func GenerateFile(plugin *protogen.Plugin, file *protogen.File) error {
	models, err := collectModels(file)
	if err != nil {
		return err
	}

	if len(models) == 0 {
		return nil
	}

	filename := file.GeneratedFilenamePrefix + ".proprdb.pb.go"
	g := plugin.NewGeneratedFile(filename, file.GoImportPath)
	hasOmitSync := false
	for _, model := range models {
		if model.OmitSync {
			hasOmitSync = true
			break
		}
	}
	g.P("// Code generated by protoc-gen-proprdb. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	g.P("import (")
	g.P(`"context"`)
	g.P(`"database/sql"`)
	g.P(`"encoding/json"`)
	g.P(`"errors"`)
	g.P(`"fmt"`)
	g.P(`"io"`)
	if hasOmitSync {
		g.P(`"log/slog"`)
	}
	g.P(`"strings"`)
	g.P()
	g.P(`"google.golang.org/protobuf/encoding/protojson"`)
	g.P(`"google.golang.org/protobuf/proto"`)
	g.P(`"google.golang.org/protobuf/types/known/anypb"`)
	g.P(`rt "github.com/fingon/proprdb/rt"`)
	g.P(")")
	g.P()

	emitShared(g)
	for _, model := range models {
		emitModel(g, model)
	}
	emitWrapper(g, models)

	return nil
}

func collectModels(file *protogen.File) ([]messageModel, error) {
	models := make([]messageModel, 0)
	for _, message := range file.Messages {
		if err := appendMessageModels(&models, message); err != nil {
			return nil, err
		}
	}

	return models, nil
}

func appendMessageModels(models *[]messageModel, message *protogen.Message) error {
	if !message.Desc.IsMapEntry() {
		model, err := buildModel(message)
		if err != nil {
			return err
		}

		if model.GoName != "" {
			*models = append(*models, model)
		}
	}

	for _, nested := range message.Messages {
		if err := appendMessageModels(models, nested); err != nil {
			return err
		}
	}

	return nil
}

func buildModel(message *protogen.Message) (messageModel, error) {
	omitTable, err := messageOptionBool(message, proprdbpb.E_OmitTable)
	if err != nil {
		return messageModel{}, fmt.Errorf("message %s omit_table option: %w", message.Desc.FullName(), err)
	}
	if omitTable {
		return messageModel{}, nil
	}
	omitSync, err := messageOptionBool(message, proprdbpb.E_OmitSync)
	if err != nil {
		return messageModel{}, fmt.Errorf("message %s omit_sync option: %w", message.Desc.FullName(), err)
	}
	validateWrite, err := messageOptionBool(message, proprdbpb.E_ValidateWrite)
	if err != nil {
		return messageModel{}, fmt.Errorf("message %s validate_write option: %w", message.Desc.FullName(), err)
	}
	projected := make([]projectedField, 0)
	signatures := make([]string, 0)

	for _, field := range message.Fields {
		external, err := fieldExternal(field)
		if err != nil {
			return messageModel{}, fmt.Errorf("field %s: %w", field.Desc.FullName(), err)
		}

		if !external {
			continue
		}

		projection, err := projectedFieldFromProto(field)
		if err != nil {
			return messageModel{}, fmt.Errorf("field %s: %w", field.Desc.FullName(), err)
		}

		projected = append(projected, projection)
		signatures = append(signatures, projection.SchemaSignature)
	}

	return messageModel{
		GoName:           message.GoIdent.GoName,
		TableName:        tableNameForMessage(message),
		TypeName:         string(message.Desc.FullName()),
		TableTypeName:    message.GoIdent.GoName + "Table",
		RowTypeName:      message.GoIdent.GoName + "Row",
		ProjectionSchema: strings.Join(signatures, ";"),
		ProjectedFields:  projected,
		OmitSync:         omitSync,
		ValidateWrite:    validateWrite,
	}, nil
}

func messageOptionBool(message *protogen.Message, extension protoreflect.ExtensionType) (bool, error) {
	messageOptions, ok := message.Desc.Options().(*descriptorpb.MessageOptions)
	if !ok || messageOptions == nil {
		return false, nil
	}
	if !proto.HasExtension(messageOptions, extension) {
		return false, nil
	}
	value := proto.GetExtension(messageOptions, extension)
	switch enabled := value.(type) {
	case bool:
		return enabled, nil
	case *bool:
		if enabled == nil {
			return false, nil
		}
		return *enabled, nil
	default:
		return false, fmt.Errorf("unexpected option type %T", value)
	}
}

func fieldExternal(field *protogen.Field) (bool, error) {
	fieldOptions, ok := field.Desc.Options().(*descriptorpb.FieldOptions)
	if !ok || fieldOptions == nil {
		return false, nil
	}

	if !proto.HasExtension(fieldOptions, proprdbpb.E_External) {
		return false, nil
	}

	value := proto.GetExtension(fieldOptions, proprdbpb.E_External)

	switch external := value.(type) {
	case bool:
		return external, nil
	case *bool:
		if external == nil {
			return false, nil
		}

		return *external, nil
	default:
		return false, fmt.Errorf("unexpected proprdb.external type %T", value)
	}
}

func projectedFieldFromProto(field *protogen.Field) (projectedField, error) {
	if field.Desc.IsList() || field.Desc.IsMap() {
		return projectedField{}, errors.New("external field must be scalar")
	}

	columnName := string(field.Desc.Name())
	getterName := "Get" + field.GoName
	signature := fmt.Sprintf("%s:%s", columnName, field.Desc.Kind())

	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		return projectedField{columnName, getterName, "INTEGER", "0", signature}, nil
	case protoreflect.Int32Kind,
		protoreflect.Sint32Kind,
		protoreflect.Sfixed32Kind,
		protoreflect.Int64Kind,
		protoreflect.Sint64Kind,
		protoreflect.Sfixed64Kind,
		protoreflect.Uint32Kind,
		protoreflect.Fixed32Kind,
		protoreflect.Uint64Kind,
		protoreflect.Fixed64Kind,
		protoreflect.EnumKind:
		return projectedField{columnName, getterName, "INTEGER", "0", signature}, nil
	case protoreflect.FloatKind, protoreflect.DoubleKind:
		return projectedField{columnName, getterName, "REAL", "0", signature}, nil
	case protoreflect.StringKind:
		return projectedField{columnName, getterName, "TEXT", "''", signature}, nil
	case protoreflect.BytesKind:
		return projectedField{columnName, getterName, "BLOB", "X''", signature}, nil
	default:
		return projectedField{}, fmt.Errorf("unsupported external field kind %s", field.Desc.Kind())
	}
}

func tableNameForMessage(message *protogen.Message) string {
	fullName := strings.ReplaceAll(string(message.Desc.FullName()), ".", "_")
	return strings.ToLower(fullName)
}

func emitShared(g *protogen.GeneratedFile) {
	g.P("type DBTX = rt.DBTX")
	g.P("type proprdbJSONLRecord = rt.JSONLRecord")
	g.P()
}

func emitModel(g *protogen.GeneratedFile, model messageModel) {
	tableNameConst := model.GoName + "TableName"
	typeNameConst := model.GoName + "TypeName"
	schemaConst := model.GoName + "ProjectionSchema"
	createTableConst := model.GoName + "CreateTableSQL"
	insertConst := model.GoName + "InsertSQL"
	upsertConst := model.GoName + "UpsertSQL"
	reprojectConst := model.GoName + "ReprojectSQL"

	g.P("const ", tableNameConst, " = ", strconv.Quote(model.TableName))
	g.P("const ", typeNameConst, " = ", strconv.Quote(model.TypeName))
	g.P("const ", schemaConst, " = ", strconv.Quote(model.ProjectionSchema))
	g.P("const ", createTableConst, " = ", strconv.Quote(createTableSQL(model)))
	g.P("const ", insertConst, " = ", strconv.Quote(insertSQL(model, false)))
	g.P("const ", upsertConst, " = ", strconv.Quote(insertSQL(model, true)))
	if len(model.ProjectedFields) > 0 {
		g.P("const ", reprojectConst, " = ", strconv.Quote(reprojectSQL(model)))
	}
	g.P()

	g.P("type ", model.RowTypeName, " struct {")
	g.P("\tID string")
	g.P("\tAtNs int64")
	g.P("\tData *", model.GoName)
	g.P("}")
	g.P()

	g.P("type ", model.TableTypeName, " struct {")
	g.P("\tq DBTX")
	g.P("}")
	g.P()

	g.P("func New", model.TableTypeName, "(q DBTX) *", model.TableTypeName, " {")
	g.P("\treturn &", model.TableTypeName, "{q: q}")
	g.P("}")
	g.P()

	emitInitMethod(g, model, tableNameConst, schemaConst, createTableConst)
	emitSelectMethod(g, model, tableNameConst)
	emitInsertMethod(g, model, tableNameConst, insertConst)
	emitUpdateMethod(g, model, tableNameConst, upsertConst)
	emitDeleteMethod(g, model, tableNameConst)
	emitApplyWithAtNsMethods(g, model, tableNameConst, upsertConst)
	if len(model.ProjectedFields) > 0 {
		emitReprojectMethod(g, model, tableNameConst, reprojectConst)
	}
}

func emitInitMethod(g *protogen.GeneratedFile, model messageModel, tableNameConst, schemaConst, createTableConst string) {
	g.P("func (t *", model.TableTypeName, ") Init() error {")
	g.P("\tif t.q == nil {")
	g.P("\t\treturn errors.New(\"nil DBTX\")")
	g.P("\t}")
	g.P("\tif err := rt.EnsureCoreTables(t.q); err != nil {")
	g.P("\t\treturn err")
	g.P("\t}")
	g.P("\tctx := context.Background()")
	g.P("\tif _, err := t.q.ExecContext(ctx, ", createTableConst, "); err != nil {")
	g.P("\t\treturn fmt.Errorf(\"create table %s: %w\", ", tableNameConst, ", err)")
	g.P("\t}")

	if len(model.ProjectedFields) > 0 {
		g.P("\tcolumnRows, err := t.q.QueryContext(ctx, `PRAGMA table_info(\"`+", tableNameConst, "+`\")`)")
		g.P("\tif err != nil {")
		g.P("\t\treturn fmt.Errorf(\"read columns for %s: %w\", ", tableNameConst, ", err)")
		g.P("\t}")
		g.P("\tdefer func() { _ = columnRows.Close() }()")
		g.P("\texistingColumns := make(map[string]bool)")
		g.P("\tfor columnRows.Next() {")
		g.P("\t\tvar cid int")
		g.P("\t\tvar name string")
		g.P("\t\tvar colType string")
		g.P("\t\tvar notNull int")
		g.P("\t\tvar defaultValue any")
		g.P("\t\tvar pk int")
		g.P("\t\tif err := columnRows.Scan(&cid, &name, &colType, &notNull, &defaultValue, &pk); err != nil {")
		g.P("\t\t\treturn fmt.Errorf(\"scan pragma row: %w\", err)")
		g.P("\t\t}")
		g.P("\t\texistingColumns[name] = true")
		g.P("\t}")
		g.P("\tif err := columnRows.Err(); err != nil {")
		g.P("\t\treturn fmt.Errorf(\"iterate pragma rows: %w\", err)")
		g.P("\t}")
		for _, projectedField := range model.ProjectedFields {
			g.P("\tif !existingColumns[", strconv.Quote(projectedField.ColumnName), "] {")
			g.P("\t\tif _, err := t.q.ExecContext(ctx, `ALTER TABLE \"`+", tableNameConst, "+`\" ADD COLUMN \"", projectedField.ColumnName, "\" ", projectedField.SQLiteType, " NOT NULL DEFAULT ", projectedField.SQLiteDefault, "`); err != nil {")
			g.P("\t\t\treturn fmt.Errorf(\"add projection column ", projectedField.ColumnName, " to %s: %w\", ", tableNameConst, ", err)")
			g.P("\t\t}")
			g.P("\t}")
		}
	}

	g.P("\tvar currentSchema string")
	g.P("\tschemaErr := t.q.QueryRowContext(ctx, `SELECT schema_hash FROM _proprdb_schema WHERE table_name = ?`, ", tableNameConst, ").Scan(&currentSchema)")
	g.P("\tif errors.Is(schemaErr, sql.ErrNoRows) {")
	g.P("\t\tif _, insertErr := t.q.ExecContext(ctx, `INSERT INTO _proprdb_schema (table_name, schema_hash) VALUES (?, ?)`, ", tableNameConst, ", ", schemaConst, "); insertErr != nil {")
	g.P("\t\t\treturn fmt.Errorf(\"insert schema hash for %s: %w\", ", tableNameConst, ", insertErr)")
	g.P("\t\t}")
	g.P("\t\treturn nil")
	g.P("\t}")
	g.P("\tif schemaErr != nil {")
	g.P("\t\treturn fmt.Errorf(\"select schema hash for %s: %w\", ", tableNameConst, ", schemaErr)")
	g.P("\t}")
	g.P("\tif currentSchema == ", schemaConst, " {")
	g.P("\t\treturn nil")
	g.P("\t}")
	if len(model.ProjectedFields) > 0 {
		g.P("\tif err := t.reproject(); err != nil {")
		g.P("\t\treturn fmt.Errorf(\"reproject table %s: %w\", ", tableNameConst, ", err)")
		g.P("\t}")
	}
	g.P("\tif _, err := t.q.ExecContext(ctx, `UPDATE _proprdb_schema SET schema_hash = ? WHERE table_name = ?`, ", schemaConst, ", ", tableNameConst, "); err != nil {")
	g.P("\t\treturn fmt.Errorf(\"update schema hash for %s: %w\", ", tableNameConst, ", err)")
	g.P("\t}")
	g.P("\treturn nil")
	g.P("}")
	g.P()
}

func emitSelectMethod(g *protogen.GeneratedFile, model messageModel, tableNameConst string) {
	g.P("func (t *", model.TableTypeName, ") Select(where string, args ...any) ([]", model.RowTypeName, ", error) {")
	g.P("\tif t.q == nil {")
	g.P("\t\treturn nil, errors.New(\"nil DBTX\")")
	g.P("\t}")
	g.P("\tctx := context.Background()")
	g.P("\tquery := `SELECT id, at_ns, data FROM \"`+", tableNameConst, "+`\"`")
	g.P("\tif strings.TrimSpace(where) != \"\" {")
	g.P("\t\tquery += \" WHERE \" + where")
	g.P("\t}")
	g.P("\trows, err := t.q.QueryContext(ctx, query, args...)")
	g.P("\tif err != nil {")
	g.P("\t\treturn nil, fmt.Errorf(\"select from %s: %w\", ", tableNameConst, ", err)")
	g.P("\t}")
	g.P("\tdefer func() { _ = rows.Close() }()")
	g.P("\tresult := make([]", model.RowTypeName, ", 0)")
	g.P("\tfor rows.Next() {")
	g.P("\t\tvar id string")
	g.P("\t\tvar atNs int64")
	g.P("\t\tvar dataBytes []byte")
	g.P("\t\tif err := rows.Scan(&id, &atNs, &dataBytes); err != nil {")
	g.P("\t\t\treturn nil, fmt.Errorf(\"scan row from %s: %w\", ", tableNameConst, ", err)")
	g.P("\t\t}")
	g.P("\t\tdata := &", model.GoName, "{}")
	g.P("\t\tif err := proto.Unmarshal(dataBytes, data); err != nil {")
	g.P("\t\t\treturn nil, fmt.Errorf(\"unmarshal ", model.GoName, " row: %w\", err)")
	g.P("\t\t}")
	g.P("\t\tresult = append(result, ", model.RowTypeName, "{ID: id, AtNs: atNs, Data: data})")
	g.P("\t}")
	g.P("\tif err := rows.Err(); err != nil {")
	g.P("\t\treturn nil, fmt.Errorf(\"iterate rows from %s: %w\", ", tableNameConst, ", err)")
	g.P("\t}")
	g.P("\treturn result, nil")
	g.P("}")
	g.P()
}

func emitInsertMethod(g *protogen.GeneratedFile, model messageModel, tableNameConst, insertConst string) {
	g.P("func (t *", model.TableTypeName, ") Insert(data *", model.GoName, ") (", model.RowTypeName, ", error) {")
	g.P("\tif t.q == nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, errors.New(\"nil DBTX\")")
	g.P("\t}")
	g.P("\tif data == nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, errors.New(\"nil data\")")
	g.P("\t}")
	g.P("\tctx := context.Background()")
	g.P("\tid, err := rt.UUIDv7()")
	g.P("\tif err != nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, fmt.Errorf(\"generate uuidv7: %w\", err)")
	g.P("\t}")
	g.P("\tif err := rt.ValidateUUID(id); err != nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, fmt.Errorf(\"validate generated id %s: %w\", id, err)")
	g.P("\t}")
	if model.ValidateWrite {
		g.P("\tif err := data.Valid(); err != nil {")
		g.P("\t\treturn ", model.RowTypeName, "{}, fmt.Errorf(\"validate ", model.GoName, ": %w\", err)")
		g.P("\t}")
	}
	g.P("\tatNs := rt.NowNs()")
	g.P("\tdataBytes, err := proto.Marshal(data)")
	g.P("\tif err != nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, fmt.Errorf(\"marshal ", model.GoName, ": %w\", err)")
	g.P("\t}")
	g.P("\tif _, err := t.q.ExecContext(ctx, `DELETE FROM _deleted WHERE table_name = ? AND id = ?`, ", tableNameConst, ", id); err != nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, fmt.Errorf(\"delete tombstone for %s/%s: %w\", ", tableNameConst, ", id, err)")
	g.P("\t}")
	g.P("\tinsertArgs := []any{id, atNs, dataBytes}")
	for _, projectedField := range model.ProjectedFields {
		g.P("\tinsertArgs = append(insertArgs, data.", projectedField.GetterName, "())")
	}
	g.P("\tif _, err := t.q.ExecContext(ctx, ", insertConst, ", insertArgs...); err != nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, fmt.Errorf(\"insert into %s: %w\", ", tableNameConst, ", err)")
	g.P("\t}")
	g.P("\treturn ", model.RowTypeName, "{ID: id, AtNs: atNs, Data: data}, nil")
	g.P("}")
	g.P()
}

func emitUpdateMethod(g *protogen.GeneratedFile, model messageModel, tableNameConst, upsertConst string) {
	g.P("func (t *", model.TableTypeName, ") UpdateByID(id string, data *", model.GoName, ") (", model.RowTypeName, ", error) {")
	g.P("\tif t.q == nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, errors.New(\"nil DBTX\")")
	g.P("\t}")
	g.P("\tif id == \"\" {")
	g.P("\t\treturn ", model.RowTypeName, "{}, errors.New(\"empty id\")")
	g.P("\t}")
	g.P("\tif err := rt.ValidateUUID(id); err != nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, fmt.Errorf(\"validate id %s: %w\", id, err)")
	g.P("\t}")
	g.P("\tif data == nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, errors.New(\"nil data\")")
	g.P("\t}")
	if model.ValidateWrite {
		g.P("\tif err := data.Valid(); err != nil {")
		g.P("\t\treturn ", model.RowTypeName, "{}, fmt.Errorf(\"validate ", model.GoName, ": %w\", err)")
		g.P("\t}")
	}
	g.P("\tctx := context.Background()")
	g.P("\tatNs := rt.NowNs()")
	g.P("\tdataBytes, err := proto.Marshal(data)")
	g.P("\tif err != nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, fmt.Errorf(\"marshal ", model.GoName, ": %w\", err)")
	g.P("\t}")
	g.P("\tif _, err := t.q.ExecContext(ctx, `DELETE FROM _deleted WHERE table_name = ? AND id = ?`, ", tableNameConst, ", id); err != nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, fmt.Errorf(\"delete tombstone for %s/%s: %w\", ", tableNameConst, ", id, err)")
	g.P("\t}")
	g.P("\tupdateArgs := []any{id, atNs, dataBytes}")
	for _, projectedField := range model.ProjectedFields {
		g.P("\tupdateArgs = append(updateArgs, data.", projectedField.GetterName, "())")
	}
	g.P("\tif _, err := t.q.ExecContext(ctx, ", upsertConst, ", updateArgs...); err != nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, fmt.Errorf(\"upsert into %s: %w\", ", tableNameConst, ", err)")
	g.P("\t}")
	g.P("\treturn ", model.RowTypeName, "{ID: id, AtNs: atNs, Data: data}, nil")
	g.P("}")
	g.P()

	g.P("func (t *", model.TableTypeName, ") UpdateRow(row ", model.RowTypeName, ") (", model.RowTypeName, ", error) {")
	g.P("\tif t.q == nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, errors.New(\"nil DBTX\")")
	g.P("\t}")
	g.P("\tif row.ID == \"\" {")
	g.P("\t\treturn ", model.RowTypeName, "{}, errors.New(\"empty id\")")
	g.P("\t}")
	g.P("\tif row.Data == nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, errors.New(\"nil data\")")
	g.P("\t}")
	g.P("\treturn t.UpdateByID(row.ID, row.Data)")
	g.P("}")
	g.P()
}

func emitDeleteMethod(g *protogen.GeneratedFile, model messageModel, tableNameConst string) {
	g.P("func (t *", model.TableTypeName, ") DeleteByID(id string) error {")
	g.P("\tif t.q == nil {")
	g.P("\t\treturn errors.New(\"nil DBTX\")")
	g.P("\t}")
	g.P("\tif id == \"\" {")
	g.P("\t\treturn errors.New(\"empty id\")")
	g.P("\t}")
	g.P("\tctx := context.Background()")
	g.P("\tatNs := rt.NowNs()")
	g.P("\tif _, err := t.q.ExecContext(ctx, `INSERT INTO _deleted (table_name, id, at_ns) VALUES (?, ?, ?) ON CONFLICT(table_name, id) DO UPDATE SET at_ns = excluded.at_ns`, ", tableNameConst, ", id, atNs); err != nil {")
	g.P("\t\treturn fmt.Errorf(\"insert tombstone for %s/%s: %w\", ", tableNameConst, ", id, err)")
	g.P("\t}")
	g.P("\tif _, err := t.q.ExecContext(ctx, `DELETE FROM \"`+", tableNameConst, "+`\" WHERE id = ?`, id); err != nil {")
	g.P("\t\treturn fmt.Errorf(\"delete from %s/%s: %w\", ", tableNameConst, ", id, err)")
	g.P("\t}")
	g.P("\treturn nil")
	g.P("}")
	g.P()

	g.P("func (t *", model.TableTypeName, ") DeleteRow(row ", model.RowTypeName, ") error {")
	g.P("\tif t.q == nil {")
	g.P("\t\treturn errors.New(\"nil DBTX\")")
	g.P("\t}")
	g.P("\tif row.ID == \"\" {")
	g.P("\t\treturn errors.New(\"empty id\")")
	g.P("\t}")
	g.P("\treturn t.DeleteByID(row.ID)")
	g.P("}")
	g.P()
}

func emitApplyWithAtNsMethods(g *protogen.GeneratedFile, model messageModel, tableNameConst, upsertConst string) {
	g.P("func (t *", model.TableTypeName, ") upsertWithAtNs(id string, atNs int64, data *", model.GoName, ") error {")
	g.P("\tif t.q == nil {")
	g.P("\t\treturn errors.New(\"nil DBTX\")")
	g.P("\t}")
	g.P("\tif id == \"\" {")
	g.P("\t\treturn errors.New(\"empty id\")")
	g.P("\t}")
	g.P("\tif data == nil {")
	g.P("\t\treturn errors.New(\"nil data\")")
	g.P("\t}")
	g.P("\tctx := context.Background()")
	g.P("\tdataBytes, err := proto.Marshal(data)")
	g.P("\tif err != nil {")
	g.P("\t\treturn fmt.Errorf(\"marshal ", model.GoName, ": %w\", err)")
	g.P("\t}")
	g.P("\tif _, err := t.q.ExecContext(ctx, `DELETE FROM _deleted WHERE table_name = ? AND id = ?`, ", tableNameConst, ", id); err != nil {")
	g.P("\t\treturn fmt.Errorf(\"delete tombstone for %s/%s: %w\", ", tableNameConst, ", id, err)")
	g.P("\t}")
	g.P("\tupsertArgs := []any{id, atNs, dataBytes}")
	for _, projectedField := range model.ProjectedFields {
		g.P("\tupsertArgs = append(upsertArgs, data.", projectedField.GetterName, "())")
	}
	g.P("\tif _, err := t.q.ExecContext(ctx, ", upsertConst, ", upsertArgs...); err != nil {")
	g.P("\t\treturn fmt.Errorf(\"upsert into %s: %w\", ", tableNameConst, ", err)")
	g.P("\t}")
	g.P("\treturn nil")
	g.P("}")
	g.P()
	g.P("func (t *", model.TableTypeName, ") tombstoneWithAtNs(id string, atNs int64) error {")
	g.P("\tif t.q == nil {")
	g.P("\t\treturn errors.New(\"nil DBTX\")")
	g.P("\t}")
	g.P("\tif id == \"\" {")
	g.P("\t\treturn errors.New(\"empty id\")")
	g.P("\t}")
	g.P("\tctx := context.Background()")
	g.P("\tif _, err := t.q.ExecContext(ctx, `INSERT INTO _deleted (table_name, id, at_ns) VALUES (?, ?, ?) ON CONFLICT(table_name, id) DO UPDATE SET at_ns = excluded.at_ns`, ", tableNameConst, ", id, atNs); err != nil {")
	g.P("\t\treturn fmt.Errorf(\"insert tombstone for %s/%s: %w\", ", tableNameConst, ", id, err)")
	g.P("\t}")
	g.P("\tif _, err := t.q.ExecContext(ctx, `DELETE FROM \"`+", tableNameConst, "+`\" WHERE id = ?`, id); err != nil {")
	g.P("\t\treturn fmt.Errorf(\"delete from %s/%s: %w\", ", tableNameConst, ", id, err)")
	g.P("\t}")
	g.P("\treturn nil")
	g.P("}")
	g.P()
}

func emitReprojectMethod(g *protogen.GeneratedFile, model messageModel, tableNameConst, reprojectConst string) {
	g.P("func (t *", model.TableTypeName, ") reproject() error {")
	g.P("\tctx := context.Background()")
	g.P("\trows, err := t.q.QueryContext(ctx, `SELECT id, data FROM \"`+", tableNameConst, "+`\"`)")
	g.P("\tif err != nil {")
	g.P("\t\treturn fmt.Errorf(\"query rows for reprojection: %w\", err)")
	g.P("\t}")
	g.P("\ttype reprojectRow struct {")
	g.P("\t\tid string")
	g.P("\t\tdataBytes []byte")
	g.P("\t}")
	g.P("\trowBuffer := make([]reprojectRow, 0)")
	g.P("\tfor rows.Next() {")
	g.P("\t\tvar id string")
	g.P("\t\tvar dataBytes []byte")
	g.P("\t\tif err := rows.Scan(&id, &dataBytes); err != nil {")
	g.P("\t\t\treturn fmt.Errorf(\"scan reprojection row: %w\", err)")
	g.P("\t\t}")
	g.P("\t\tcopiedData := make([]byte, len(dataBytes))")
	g.P("\t\tcopy(copiedData, dataBytes)")
	g.P("\t\trowBuffer = append(rowBuffer, reprojectRow{id: id, dataBytes: copiedData})")
	g.P("\t}")
	g.P("\tif err := rows.Err(); err != nil {")
	g.P("\t\treturn fmt.Errorf(\"iterate reprojection rows: %w\", err)")
	g.P("\t}")
	g.P("\tif err := rows.Close(); err != nil {")
	g.P("\t\treturn fmt.Errorf(\"close reprojection rows: %w\", err)")
	g.P("\t}")
	g.P("\tfor _, row := range rowBuffer {")
	g.P("\t\tdata := &", model.GoName, "{}")
	g.P("\t\tif err := proto.Unmarshal(row.dataBytes, data); err != nil {")
	g.P("\t\t\treturn fmt.Errorf(\"unmarshal reprojection row: %w\", err)")
	g.P("\t\t}")
	g.P("\t\treprojectArgs := []any{}")
	for _, projectedField := range model.ProjectedFields {
		g.P("\t\treprojectArgs = append(reprojectArgs, data.", projectedField.GetterName, "())")
	}
	g.P("\t\treprojectArgs = append(reprojectArgs, row.id)")
	g.P("\t\tif _, err := t.q.ExecContext(ctx, ", reprojectConst, ", reprojectArgs...); err != nil {")
	g.P("\t\t\treturn fmt.Errorf(\"reproject row %s: %w\", row.id, err)")
	g.P("\t\t}")
	g.P("\t}")
	g.P("\treturn nil")
	g.P("}")
	g.P()
}

func emitWrapper(g *protogen.GeneratedFile, models []messageModel) {
	syncModels := make([]messageModel, 0, len(models))
	for _, model := range models {
		if !model.OmitSync {
			syncModels = append(syncModels, model)
		}
	}

	g.P("type CRUD struct {")
	for _, model := range models {
		g.P("\t", model.GoName, " *", model.TableTypeName)
	}
	g.P("}")
	g.P()
	g.P("func NewCRUD(q DBTX) *CRUD {")
	g.P("\treturn &CRUD{")
	for _, model := range models {
		g.P("\t\t", model.GoName, ": New", model.TableTypeName, "(q),")
	}
	g.P("\t}")
	g.P("}")
	g.P()
	g.P("func (c *CRUD) dbtx() (DBTX, error) {")
	g.P("\tif c == nil {")
	g.P("\t\treturn nil, errors.New(\"nil CRUD\")")
	g.P("\t}")
	for _, model := range models {
		g.P("\tif c.", model.GoName, " != nil && c.", model.GoName, ".q != nil {")
		g.P("\t\treturn c.", model.GoName, ".q, nil")
		g.P("\t}")
	}
	g.P("\treturn nil, errors.New(\"nil DBTX\")")
	g.P("}")
	g.P()
	g.P("func (c *CRUD) Init() error {")
	for _, model := range models {
		g.P("\tif err := c.", model.GoName, ".Init(); err != nil {")
		g.P("\t\treturn fmt.Errorf(\"init ", model.GoName, " table: %w\", err)")
		g.P("\t}")
	}
	g.P("\treturn nil")
	g.P("}")
	g.P()
	g.P("func (c *CRUD) WriteJSONL(remote string, w io.Writer) error {")
	g.P("\tif strings.TrimSpace(remote) == \"\" {")
	g.P("\t\treturn errors.New(\"empty remote\")")
	g.P("\t}")
	g.P("\tif w == nil {")
	g.P("\t\treturn errors.New(\"nil writer\")")
	g.P("\t}")
	g.P("\tq, err := c.dbtx()")
	g.P("\tif err != nil {")
	g.P("\t\treturn err")
	g.P("\t}")
	g.P("\tencoder := json.NewEncoder(w)")
	for _, model := range syncModels {
		g.P("\t", strings.ToLower(model.GoName), "Rows, err := c.", model.GoName, ".Select(\"\")")
		g.P("\tif err != nil {")
		g.P("\t\treturn fmt.Errorf(\"select ", model.GoName, " rows for jsonl write: %w\", err)")
		g.P("\t}")
		g.P("\tfor _, row := range ", strings.ToLower(model.GoName), "Rows {")
		g.P("\t\tneedsSend, err := rt.SyncNeedsSend(q, row.ID, ", model.GoName, "TableName, remote, row.AtNs)")
		g.P("\t\tif err != nil {")
		g.P("\t\t\treturn err")
		g.P("\t\t}")
		g.P("\t\tif !needsSend {")
		g.P("\t\t\tcontinue")
		g.P("\t\t}")
		g.P("\t\tdataJSON, err := rt.MarshalAnyJSON(row.Data)")
		g.P("\t\tif err != nil {")
		g.P("\t\t\treturn fmt.Errorf(\"marshal ", model.GoName, " %s for jsonl write: %w\", row.ID, err)")
		g.P("\t\t}")
		g.P("\t\trecord := proprdbJSONLRecord{ID: row.ID, AtNs: row.AtNs, Data: dataJSON}")
		g.P("\t\tif err := encoder.Encode(record); err != nil {")
		g.P("\t\t\treturn fmt.Errorf(\"write jsonl row for ", model.GoName, " %s: %w\", row.ID, err)")
		g.P("\t\t}")
		g.P("\t\tif err := rt.SyncUpsert(q, row.ID, ", model.GoName, "TableName, remote, row.AtNs); err != nil {")
		g.P("\t\t\treturn err")
		g.P("\t\t}")
		g.P("\t}")
	}
	if len(syncModels) > 0 {
		tableNameCases := make([]string, 0, len(syncModels))
		for _, model := range syncModels {
			tableNameCases = append(tableNameCases, model.GoName+"TableName")
		}
		placeholders := strings.TrimRight(strings.Repeat("?,", len(syncModels)), ",")
		g.P("\ttombstoneRows, err := q.QueryContext(context.Background(), `SELECT table_name, id, at_ns FROM _deleted WHERE table_name IN ("+placeholders+")`, ", strings.Join(tableNameCases, ", "), ")")
		g.P("\tif err != nil {")
		g.P("\t\treturn fmt.Errorf(\"select tombstones for jsonl write: %w\", err)")
		g.P("\t}")
		g.P("\tdefer func() { _ = tombstoneRows.Close() }()")
		g.P("\tfor tombstoneRows.Next() {")
		g.P("\t\tvar tableName string")
		g.P("\t\tvar id string")
		g.P("\t\tvar atNs int64")
		g.P("\t\tif err := tombstoneRows.Scan(&tableName, &id, &atNs); err != nil {")
		g.P("\t\t\treturn fmt.Errorf(\"scan tombstone row: %w\", err)")
		g.P("\t\t}")
		g.P("\t\tneedsSend, err := rt.SyncNeedsSend(q, id, tableName, remote, atNs)")
		g.P("\t\tif err != nil {")
		g.P("\t\t\treturn err")
		g.P("\t\t}")
		g.P("\t\tif !needsSend {")
		g.P("\t\t\tcontinue")
		g.P("\t\t}")
		g.P("\t\tvar typeName string")
		g.P("\t\tswitch tableName {")
		for _, model := range syncModels {
			g.P("\t\tcase ", model.GoName, "TableName:")
			g.P("\t\t\ttypeName = ", model.GoName, "TypeName")
		}
		g.P("\t\tdefault:")
		g.P("\t\t\treturn fmt.Errorf(\"unsupported tombstone table %s\", tableName)")
		g.P("\t\t}")
		g.P("\t\tdataJSON, err := rt.MarshalTypeOnlyAnyJSON(typeName)")
		g.P("\t\tif err != nil {")
		g.P("\t\t\treturn fmt.Errorf(\"marshal tombstone %s/%s for jsonl write: %w\", tableName, id, err)")
		g.P("\t\t}")
		g.P("\t\trecord := proprdbJSONLRecord{ID: id, Deleted: true, AtNs: atNs, Data: dataJSON}")
		g.P("\t\tif err := encoder.Encode(record); err != nil {")
		g.P("\t\t\treturn fmt.Errorf(\"write jsonl tombstone %s/%s: %w\", tableName, id, err)")
		g.P("\t\t}")
		g.P("\t\tif err := rt.SyncUpsert(q, id, tableName, remote, atNs); err != nil {")
		g.P("\t\t\treturn err")
		g.P("\t\t}")
		g.P("\t}")
		g.P("\tif err := tombstoneRows.Err(); err != nil {")
		g.P("\t\treturn fmt.Errorf(\"iterate tombstone rows: %w\", err)")
		g.P("\t}")
	}
	g.P("\treturn nil")
	g.P("}")
	g.P()
	g.P("func (c *CRUD) ReadJSONL(remote string, r io.Reader) error {")
	g.P("\tif strings.TrimSpace(remote) == \"\" {")
	g.P("\t\treturn errors.New(\"empty remote\")")
	g.P("\t}")
	g.P("\tif r == nil {")
	g.P("\t\treturn errors.New(\"nil reader\")")
	g.P("\t}")
	g.P("\tq, err := c.dbtx()")
	g.P("\tif err != nil {")
	g.P("\t\treturn err")
	g.P("\t}")
	g.P("\treturn rt.ReadJSONL(r, func(record proprdbJSONLRecord, lineNumber int) error {")
	g.P("\t\tif record.ID == \"\" {")
	g.P("\t\t\treturn fmt.Errorf(\"jsonl line %d has empty id\", lineNumber)")
	g.P("\t\t}")
	g.P("\t\tif len(record.Data) == 0 {")
	g.P("\t\t\treturn fmt.Errorf(\"jsonl line %d has empty data\", lineNumber)")
	g.P("\t\t}")
	g.P("\t\tanyMessage := &anypb.Any{}")
	g.P("\t\tif err := protojson.Unmarshal(record.Data, anyMessage); err != nil {")
	g.P("\t\t\treturn fmt.Errorf(\"unmarshal jsonl data on line %d: %w\", lineNumber, err)")
	g.P("\t\t}")
	g.P("\t\ttypeName := rt.TypeNameFromURL(anyMessage.GetTypeUrl())")
	g.P("\t\tswitch typeName {")
	for _, model := range models {
		g.P("\t\tcase ", model.GoName, "TypeName:")
		if model.OmitSync {
			g.P("\t\t\tslog.Error(\"ignoring unsynced jsonl record\", \"type\", typeName, \"id\", record.ID, \"remote\", remote, \"line\", lineNumber)")
			g.P("\t\t\treturn nil")
			continue
		}
		g.P("\t\t\tlocalMaxAtNs, err := rt.LocalMaxAtNs(q, ", model.GoName, "TableName, record.ID)")
		g.P("\t\t\tif err != nil {")
		g.P("\t\t\t\treturn err")
		g.P("\t\t\t}")
		g.P("\t\t\tif err := rt.SyncUpsert(q, record.ID, ", model.GoName, "TableName, remote, record.AtNs); err != nil {")
		g.P("\t\t\t\treturn err")
		g.P("\t\t\t}")
		g.P("\t\t\tif record.AtNs < localMaxAtNs {")
		g.P("\t\t\t\treturn nil")
		g.P("\t\t\t}")
		g.P("\t\t\tif record.Deleted {")
		g.P("\t\t\t\tif c.", model.GoName, " == nil {")
		g.P("\t\t\t\t\treturn errors.New(\"nil ", model.GoName, " table\")")
		g.P("\t\t\t\t}")
		g.P("\t\t\t\treturn c.", model.GoName, ".tombstoneWithAtNs(record.ID, record.AtNs)")
		g.P("\t\t\t}")
		g.P("\t\t\tif c.", model.GoName, " == nil {")
		g.P("\t\t\t\treturn errors.New(\"nil ", model.GoName, " table\")")
		g.P("\t\t\t}")
		g.P("\t\t\tdata := &", model.GoName, "{}")
		g.P("\t\t\tif err := anypb.UnmarshalTo(anyMessage, data, proto.UnmarshalOptions{}); err != nil {")
		g.P("\t\t\t\treturn fmt.Errorf(\"unmarshal ", model.GoName, " data on line %d: %w\", lineNumber, err)")
		g.P("\t\t\t}")
		g.P("\t\t\treturn c.", model.GoName, ".upsertWithAtNs(record.ID, record.AtNs, data)")
	}
	g.P("\t\tdefault:")
	g.P("\t\t\treturn fmt.Errorf(\"unsupported @type on line %d: %s\", lineNumber, typeName)")
	g.P("\t\t}")
	g.P("\t})")
	g.P("}")
	g.P()
}

func createTableSQL(model messageModel) string {
	columns := []string{`"id" TEXT PRIMARY KEY`, `"at_ns" INTEGER NOT NULL`, `"data" BLOB NOT NULL`}
	for _, projectedField := range model.ProjectedFields {
		columns = append(
			columns,
			fmt.Sprintf(
				`"%s" %s NOT NULL DEFAULT %s`,
				projectedField.ColumnName,
				projectedField.SQLiteType,
				projectedField.SQLiteDefault,
			),
		)
	}

	return fmt.Sprintf(
		`CREATE TABLE IF NOT EXISTS "%s" (%s)`,
		model.TableName,
		strings.Join(columns, ", "),
	)
}

func insertSQL(model messageModel, upsert bool) string {
	columns := []string{"id", "at_ns", "data"}
	for _, projectedField := range model.ProjectedFields {
		columns = append(columns, projectedField.ColumnName)
	}

	quotedColumns := make([]string, 0, len(columns))
	for _, column := range columns {
		quotedColumns = append(quotedColumns, fmt.Sprintf(`"%s"`, column))
	}

	placeholders := make([]string, 0, len(columns))
	for range columns {
		placeholders = append(placeholders, "?")
	}

	statement := fmt.Sprintf(
		`INSERT INTO "%s" (%s) VALUES (%s)`,
		model.TableName,
		strings.Join(quotedColumns, ", "),
		strings.Join(placeholders, ", "),
	)
	if !upsert {
		return statement
	}

	updates := []string{`"at_ns" = excluded."at_ns"`, `"data" = excluded."data"`}
	for _, projectedField := range model.ProjectedFields {
		updates = append(
			updates,
			fmt.Sprintf(
				`"%s" = excluded."%s"`,
				projectedField.ColumnName,
				projectedField.ColumnName,
			),
		)
	}

	return statement + " ON CONFLICT(id) DO UPDATE SET " + strings.Join(updates, ", ")
}

func reprojectSQL(model messageModel) string {
	updates := make([]string, 0, len(model.ProjectedFields))
	for _, projectedField := range model.ProjectedFields {
		updates = append(updates, fmt.Sprintf(`"%s" = ?`, projectedField.ColumnName))
	}

	return fmt.Sprintf(
		`UPDATE "%s" SET %s WHERE id = ?`,
		model.TableName,
		strings.Join(updates, ", "),
	)
}

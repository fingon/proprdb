package proprdbgen

import (
	"errors"
	"fmt"
	"strconv"
	"strings"

	proprdbpb "github.com/fingon/proprdb/proto/proprdb"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	descriptorpb "google.golang.org/protobuf/types/descriptorpb"
)

type projectedField struct {
	ColumnName      string
	GetterName      string
	SQLiteType      string
	SQLiteDefault   string
	SchemaSignature string
}

type messageIndex struct {
	ColumnNames []string
	IndexName   string
	Signature   string
}

type messageModel struct {
	GoName              string
	TableName           string
	TypeName            string
	TableTypeName       string
	RowTypeName         string
	ProjectionSchema    string
	ProjectedFields     []projectedField
	Indexes             []messageIndex
	OmitSync            bool
	ValidateWrite       bool
	AllowCustomIDInsert bool
}

type modelCollector struct{}

type generatorEmitter struct {
	g *protogen.GeneratedFile
}

const (
	errNilDBTX = "nil DBTX"
	errNilData = "nil data"
	errEmptyID = "empty id"
)

// GenerateFile generates proprdb CRUD code for one .proto file.
func GenerateFile(plugin *protogen.Plugin, file *protogen.File) error {
	collector := modelCollector{}
	models, err := collector.collectModels(file)
	if err != nil {
		return err
	}

	if len(models) == 0 {
		return nil
	}

	filename := file.GeneratedFilenamePrefix + ".proprdb.pb.go"
	g := plugin.NewGeneratedFile(filename, file.GoImportPath)
	hasOmitSync := false
	for _, model := range models {
		if model.OmitSync {
			hasOmitSync = true
			break
		}
	}
	g.P("// Code generated by protoc-gen-proprdb. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	g.P("import (")
	g.P(`"context"`)
	g.P(`"database/sql"`)
	g.P(`"encoding/json"`)
	g.P(`"errors"`)
	g.P(`"fmt"`)
	g.P(`"io"`)
	if hasOmitSync {
		g.P(`"log/slog"`)
	}
	g.P(`"strings"`)
	g.P()
	g.P(`"google.golang.org/protobuf/encoding/protojson"`)
	g.P(`"google.golang.org/protobuf/proto"`)
	g.P(`"google.golang.org/protobuf/types/known/anypb"`)
	g.P(`rt "github.com/fingon/proprdb/rt"`)
	g.P(")")
	g.P()

	emitter := generatorEmitter{g: g}
	emitter.emitShared()
	for _, model := range models {
		emitter.emitModel(model)
	}
	emitter.emitWrapper(models)

	return nil
}

func (c modelCollector) collectModels(file *protogen.File) ([]messageModel, error) {
	models := make([]messageModel, 0)
	for _, message := range file.Messages {
		if err := c.appendMessageModels(&models, message); err != nil {
			return nil, err
		}
	}

	return models, nil
}

func (c modelCollector) appendMessageModels(models *[]messageModel, message *protogen.Message) error {
	if !message.Desc.IsMapEntry() {
		model, err := c.buildModel(message)
		if err != nil {
			return err
		}

		if model.GoName != "" {
			*models = append(*models, model)
		}
	}

	for _, nested := range message.Messages {
		if err := c.appendMessageModels(models, nested); err != nil {
			return err
		}
	}

	return nil
}

func (c modelCollector) buildModel(message *protogen.Message) (messageModel, error) {
	omitTable, err := c.messageOptionBool(message, proprdbpb.E_OmitTable)
	if err != nil {
		return messageModel{}, fmt.Errorf("message %s omit_table option: %w", message.Desc.FullName(), err)
	}
	if omitTable {
		return messageModel{}, nil
	}
	omitSync, err := c.messageOptionBool(message, proprdbpb.E_OmitSync)
	if err != nil {
		return messageModel{}, fmt.Errorf("message %s omit_sync option: %w", message.Desc.FullName(), err)
	}
	validateWrite, err := c.messageOptionBool(message, proprdbpb.E_ValidateWrite)
	if err != nil {
		return messageModel{}, fmt.Errorf("message %s validate_write option: %w", message.Desc.FullName(), err)
	}
	allowCustomIDInsert, err := c.messageOptionBool(message, proprdbpb.E_AllowCustomIdInsert)
	if err != nil {
		return messageModel{}, fmt.Errorf("message %s allow_custom_id_insert option: %w", message.Desc.FullName(), err)
	}
	projected := make([]projectedField, 0)
	signatures := make([]string, 0)
	fieldsByName := make(map[string]*protogen.Field)
	projectedByName := make(map[string]bool)

	for _, field := range message.Fields {
		fieldsByName[string(field.Desc.Name())] = field
	}

	for _, field := range message.Fields {
		external, err := c.fieldExternal(field)
		if err != nil {
			return messageModel{}, fmt.Errorf("field %s: %w", field.Desc.FullName(), err)
		}

		if !external {
			continue
		}

		projection, err := c.projectedFieldFromProto(field)
		if err != nil {
			return messageModel{}, fmt.Errorf("field %s: %w", field.Desc.FullName(), err)
		}

		projected = append(projected, projection)
		projectedByName[projection.ColumnName] = true
		signatures = append(signatures, projection.SchemaSignature)
	}

	indexes, err := c.messageOptionIndexes(message, fieldsByName, projectedByName)
	if err != nil {
		return messageModel{}, fmt.Errorf("message %s indexes option: %w", message.Desc.FullName(), err)
	}
	for _, indexModel := range indexes {
		signatures = append(signatures, indexModel.Signature)
	}

	return messageModel{
		GoName:              message.GoIdent.GoName,
		TableName:           c.tableNameForMessage(message),
		TypeName:            string(message.Desc.FullName()),
		TableTypeName:       message.GoIdent.GoName + "Table",
		RowTypeName:         message.GoIdent.GoName + "Row",
		ProjectionSchema:    strings.Join(signatures, ";"),
		ProjectedFields:     projected,
		Indexes:             indexes,
		OmitSync:            omitSync,
		ValidateWrite:       validateWrite,
		AllowCustomIDInsert: allowCustomIDInsert,
	}, nil
}

func (c modelCollector) messageOptionIndexes(message *protogen.Message, fieldsByName map[string]*protogen.Field, projectedByName map[string]bool) ([]messageIndex, error) {
	messageOptions, ok := message.Desc.Options().(*descriptorpb.MessageOptions)
	if !ok || messageOptions == nil {
		return nil, nil
	}
	if !proto.HasExtension(messageOptions, proprdbpb.E_Indexes) {
		return nil, nil
	}

	value := proto.GetExtension(messageOptions, proprdbpb.E_Indexes)
	indexDefs, ok := value.([]*proprdbpb.Index)
	if !ok {
		return nil, fmt.Errorf("unexpected com.github.fingon.proprdb.indexes type %T", value)
	}

	indexes := make([]messageIndex, 0, len(indexDefs))
	signatureSeen := make(map[string]bool)
	nameSeen := make(map[string]bool)
	tableName := c.tableNameForMessage(message)
	for indexPosition, indexDef := range indexDefs {
		if indexDef == nil {
			return nil, fmt.Errorf("index %d is nil", indexPosition+1)
		}
		if len(indexDef.Fields) == 0 {
			return nil, fmt.Errorf("index %d must include at least one field", indexPosition+1)
		}
		columnNames := make([]string, 0, len(indexDef.Fields))
		columnSeen := make(map[string]bool)
		for fieldPosition, rawFieldName := range indexDef.Fields {
			fieldName := strings.TrimSpace(rawFieldName)
			if fieldName == "" {
				return nil, fmt.Errorf("index %d field %d is empty", indexPosition+1, fieldPosition+1)
			}
			if columnSeen[fieldName] {
				return nil, fmt.Errorf("index %d has duplicate field %q", indexPosition+1, fieldName)
			}
			if _, ok := fieldsByName[fieldName]; !ok {
				return nil, fmt.Errorf("index %d references unknown field %q", indexPosition+1, fieldName)
			}
			if !projectedByName[fieldName] {
				return nil, fmt.Errorf("index %d field %q must be marked (com.github.fingon.proprdb.external)=true", indexPosition+1, fieldName)
			}
			columnSeen[fieldName] = true
			columnNames = append(columnNames, fieldName)
		}
		signature := "idx:" + strings.Join(columnNames, ",")
		if signatureSeen[signature] {
			return nil, fmt.Errorf("duplicate index declaration for fields %q", strings.Join(columnNames, ","))
		}
		signatureSeen[signature] = true

		indexName := c.generatedIndexName(tableName, columnNames)
		if nameSeen[indexName] {
			return nil, fmt.Errorf("index name collision for generated name %q", indexName)
		}
		nameSeen[indexName] = true

		indexes = append(indexes, messageIndex{
			ColumnNames: columnNames,
			IndexName:   indexName,
			Signature:   signature,
		})
	}

	return indexes, nil
}

func (c modelCollector) messageOptionBool(message *protogen.Message, extension protoreflect.ExtensionType) (bool, error) {
	messageOptions, ok := message.Desc.Options().(*descriptorpb.MessageOptions)
	if !ok || messageOptions == nil {
		return false, nil
	}
	if !proto.HasExtension(messageOptions, extension) {
		return false, nil
	}
	value := proto.GetExtension(messageOptions, extension)
	switch enabled := value.(type) {
	case bool:
		return enabled, nil
	case *bool:
		if enabled == nil {
			return false, nil
		}
		return *enabled, nil
	default:
		return false, fmt.Errorf("unexpected option type %T", value)
	}
}

func (c modelCollector) fieldExternal(field *protogen.Field) (bool, error) {
	fieldOptions, ok := field.Desc.Options().(*descriptorpb.FieldOptions)
	if !ok || fieldOptions == nil {
		return false, nil
	}

	if !proto.HasExtension(fieldOptions, proprdbpb.E_External) {
		return false, nil
	}

	value := proto.GetExtension(fieldOptions, proprdbpb.E_External)

	switch external := value.(type) {
	case bool:
		return external, nil
	case *bool:
		if external == nil {
			return false, nil
		}

		return *external, nil
	default:
		return false, fmt.Errorf("unexpected com.github.fingon.proprdb.external type %T", value)
	}
}

func (c modelCollector) projectedFieldFromProto(field *protogen.Field) (projectedField, error) {
	if field.Desc.IsList() || field.Desc.IsMap() {
		return projectedField{}, errors.New("external field must be scalar")
	}

	columnName := string(field.Desc.Name())
	getterName := "Get" + field.GoName
	signature := fmt.Sprintf("%s:%s", columnName, field.Desc.Kind())

	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		return projectedField{columnName, getterName, "INTEGER", "0", signature}, nil
	case protoreflect.Int32Kind,
		protoreflect.Sint32Kind,
		protoreflect.Sfixed32Kind,
		protoreflect.Int64Kind,
		protoreflect.Sint64Kind,
		protoreflect.Sfixed64Kind,
		protoreflect.Uint32Kind,
		protoreflect.Fixed32Kind,
		protoreflect.Uint64Kind,
		protoreflect.Fixed64Kind,
		protoreflect.EnumKind:
		return projectedField{columnName, getterName, "INTEGER", "0", signature}, nil
	case protoreflect.FloatKind, protoreflect.DoubleKind:
		return projectedField{columnName, getterName, "REAL", "0", signature}, nil
	case protoreflect.StringKind:
		return projectedField{columnName, getterName, "TEXT", "''", signature}, nil
	case protoreflect.BytesKind:
		return projectedField{columnName, getterName, "BLOB", "X''", signature}, nil
	default:
		return projectedField{}, fmt.Errorf("unsupported external field kind %s", field.Desc.Kind())
	}
}

func (c modelCollector) tableNameForMessage(message *protogen.Message) string {
	fullName := strings.ReplaceAll(string(message.Desc.FullName()), ".", "_")
	return strings.ToLower(fullName)
}

func (c modelCollector) generatedIndexName(tableName string, columnNames []string) string {
	prefix := "idx_" + sanitizeSQLName(tableName) + "__"
	sanitizedColumns := make([]string, 0, len(columnNames))
	for _, columnName := range columnNames {
		sanitizedColumns = append(sanitizedColumns, sanitizeSQLName(columnName))
	}
	return prefix + strings.Join(sanitizedColumns, "_")
}

func sanitizeSQLName(value string) string {
	builder := strings.Builder{}
	lastUnderscore := false
	for _, character := range strings.ToLower(value) {
		isLower := character >= 'a' && character <= 'z'
		isDigit := character >= '0' && character <= '9'
		if isLower || isDigit {
			builder.WriteRune(character)
			lastUnderscore = false
			continue
		}
		if lastUnderscore {
			continue
		}
		builder.WriteByte('_')
		lastUnderscore = true
	}
	result := strings.Trim(builder.String(), "_")
	if result == "" {
		return "idx"
	}
	return result
}

func (e generatorEmitter) emitShared() {
	g := e.g
	g.P("type DBTX = rt.DBTX")
	g.P("type proprdbJSONLRecord = rt.JSONLRecord")
	g.P()
}

func (e generatorEmitter) emitModel(model messageModel) {
	g := e.g
	tableNameConst := model.GoName + "TableName"
	typeNameConst := model.GoName + "TypeName"
	schemaConst := model.GoName + "ProjectionSchema"
	createTableConst := model.GoName + "CreateTableSQL"
	insertConst := model.GoName + "InsertSQL"
	upsertConst := model.GoName + "UpsertSQL"
	reprojectConst := model.GoName + "ReprojectSQL"
	indexPrefixConst := model.GoName + "GeneratedIndexPrefix"
	indexCreateConstPrefix := model.GoName + "CreateIndexSQL"

	g.P("const ", tableNameConst, " = ", strconv.Quote(model.TableName))
	g.P("const ", typeNameConst, " = ", strconv.Quote(model.TypeName))
	g.P("const ", schemaConst, " = ", strconv.Quote(model.ProjectionSchema))
	g.P("const ", createTableConst, " = ", strconv.Quote(model.createTableSQL()))
	g.P("const ", insertConst, " = ", strconv.Quote(model.insertSQL(false)))
	g.P("const ", upsertConst, " = ", strconv.Quote(model.insertSQL(true)))
	g.P("const ", indexPrefixConst, " = ", strconv.Quote(model.generatedIndexPrefix()))
	for indexPosition, indexModel := range model.Indexes {
		g.P("const ", indexCreateConstPrefix, strconv.Itoa(indexPosition+1), " = ", strconv.Quote(model.createIndexSQL(indexModel)))
	}
	if len(model.ProjectedFields) > 0 {
		g.P("const ", reprojectConst, " = ", strconv.Quote(model.reprojectSQL()))
	}
	g.P()

	g.P("type ", model.RowTypeName, " struct {")
	g.P("\tID string")
	g.P("\tAtNs int64")
	g.P("\tData *", model.GoName)
	g.P("}")
	g.P()

	g.P("type ", model.TableTypeName, " struct {")
	g.P("\tq DBTX")
	g.P("}")
	g.P()

	g.P("func New", model.TableTypeName, "(q DBTX) *", model.TableTypeName, " {")
	g.P("\treturn &", model.TableTypeName, "{q: q}")
	g.P("}")
	g.P()

	e.emitInitMethod(model, tableNameConst, schemaConst, createTableConst, indexPrefixConst, indexCreateConstPrefix)
	e.emitSelectMethod(model, tableNameConst)
	e.emitInsertMethod(model, tableNameConst, insertConst)
	e.emitUpdateMethod(model, tableNameConst, upsertConst)
	e.emitDeleteMethod(model, tableNameConst)
	e.emitApplyWithAtNsMethods(model, tableNameConst, upsertConst)
	if len(model.ProjectedFields) > 0 {
		e.emitReprojectMethod(model, tableNameConst, reprojectConst)
	}
}

func (e generatorEmitter) emitInitMethod(model messageModel, tableNameConst, schemaConst, createTableConst, indexPrefixConst, indexCreateConstPrefix string) {
	g := e.g
	g.P("func (t *", model.TableTypeName, ") Init() error {")
	g.P("\tif t.q == nil {")
	g.P("\t\treturn errors.New(\"" + errNilDBTX + "\")")
	g.P("\t}")
	g.P("\tif err := rt.EnsureCoreTables(t.q); err != nil {")
	g.P("\t\treturn err")
	g.P("\t}")
	g.P("\tctx := context.Background()")
	g.P("\tif _, err := t.q.ExecContext(ctx, ", createTableConst, "); err != nil {")
	g.P("\t\treturn fmt.Errorf(\"create table %s: %w\", ", tableNameConst, ", err)")
	g.P("\t}")

	if len(model.ProjectedFields) > 0 {
		g.P("\tcolumnRows, err := t.q.QueryContext(ctx, `PRAGMA table_info(\"`+", tableNameConst, "+`\")`)")
		g.P("\tif err != nil {")
		g.P("\t\treturn fmt.Errorf(\"read columns for %s: %w\", ", tableNameConst, ", err)")
		g.P("\t}")
		g.P("\texistingColumns := make(map[string]bool)")
		g.P("\tfor columnRows.Next() {")
		g.P("\t\tvar cid int")
		g.P("\t\tvar name string")
		g.P("\t\tvar colType string")
		g.P("\t\tvar notNull int")
		g.P("\t\tvar defaultValue any")
		g.P("\t\tvar pk int")
		g.P("\t\tif err := columnRows.Scan(&cid, &name, &colType, &notNull, &defaultValue, &pk); err != nil {")
		g.P("\t\t\tif closeErr := rt.CloseRows(columnRows, \"projection metadata\"); closeErr != nil {")
		g.P("\t\t\t\treturn fmt.Errorf(\"scan pragma row: %w (additionally, %v)\", err, closeErr)")
		g.P("\t\t\t}")
		g.P("\t\t\treturn fmt.Errorf(\"scan pragma row: %w\", err)")
		g.P("\t\t}")
		g.P("\t\texistingColumns[name] = true")
		g.P("\t}")
		g.P("\tif err := columnRows.Err(); err != nil {")
		g.P("\t\tif closeErr := rt.CloseRows(columnRows, \"projection metadata\"); closeErr != nil {")
		g.P("\t\t\treturn fmt.Errorf(\"iterate pragma rows: %w (additionally, %v)\", err, closeErr)")
		g.P("\t\t}")
		g.P("\t\treturn fmt.Errorf(\"iterate pragma rows: %w\", err)")
		g.P("\t}")
		g.P("\tif err := rt.CloseRows(columnRows, \"projection metadata\"); err != nil {")
		g.P("\t\treturn err")
		g.P("\t}")
		for _, projectedField := range model.ProjectedFields {
			g.P("\tif !existingColumns[", strconv.Quote(projectedField.ColumnName), "] {")
			g.P("\t\tif _, err := t.q.ExecContext(ctx, `ALTER TABLE \"`+", tableNameConst, "+`\" ADD COLUMN \"", projectedField.ColumnName, "\" ", projectedField.SQLiteType, " NOT NULL DEFAULT ", projectedField.SQLiteDefault, "`); err != nil {")
			g.P("\t\t\treturn fmt.Errorf(\"add projection column ", projectedField.ColumnName, " to %s: %w\", ", tableNameConst, ", err)")
			g.P("\t\t}")
			g.P("\t}")
		}
	}

	g.P("\tif err := rt.EnsureManagedIndexes(t.q, ", tableNameConst, ", ", indexPrefixConst, ", []string{")
	for indexPosition := range model.Indexes {
		g.P("\t\t", indexCreateConstPrefix, strconv.Itoa(indexPosition+1), ",")
	}
	g.P("\t}, []string{")
	for _, indexModel := range model.Indexes {
		g.P("\t\t", strconv.Quote(indexModel.IndexName), ",")
	}
	g.P("\t}); err != nil {")
	g.P("\t\treturn err")
	g.P("\t}")

	g.P("\tvar currentSchema string")
	g.P("\tschemaErr := t.q.QueryRowContext(ctx, `SELECT schema_hash FROM _proprdb_schema WHERE table_name = ?`, ", tableNameConst, ").Scan(&currentSchema)")
	g.P("\tif errors.Is(schemaErr, sql.ErrNoRows) {")
	g.P("\t\tif _, insertErr := t.q.ExecContext(ctx, `INSERT INTO _proprdb_schema (table_name, schema_hash) VALUES (?, ?)`, ", tableNameConst, ", ", schemaConst, "); insertErr != nil {")
	g.P("\t\t\treturn fmt.Errorf(\"insert schema hash for %s: %w\", ", tableNameConst, ", insertErr)")
	g.P("\t\t}")
	g.P("\t\treturn nil")
	g.P("\t}")
	g.P("\tif schemaErr != nil {")
	g.P("\t\treturn fmt.Errorf(\"select schema hash for %s: %w\", ", tableNameConst, ", schemaErr)")
	g.P("\t}")
	g.P("\tif currentSchema == ", schemaConst, " {")
	g.P("\t\treturn nil")
	g.P("\t}")
	if len(model.ProjectedFields) > 0 {
		g.P("\tif err := t.reproject(); err != nil {")
		g.P("\t\treturn fmt.Errorf(\"reproject table %s: %w\", ", tableNameConst, ", err)")
		g.P("\t}")
	}
	g.P("\tif _, err := t.q.ExecContext(ctx, `UPDATE _proprdb_schema SET schema_hash = ? WHERE table_name = ?`, ", schemaConst, ", ", tableNameConst, "); err != nil {")
	g.P("\t\treturn fmt.Errorf(\"update schema hash for %s: %w\", ", tableNameConst, ", err)")
	g.P("\t}")
	g.P("\treturn nil")
	g.P("}")
	g.P()
}

func (e generatorEmitter) emitSelectMethod(model messageModel, tableNameConst string) {
	g := e.g
	g.P("func (t *", model.TableTypeName, ") Select(where string, args ...any) ([]", model.RowTypeName, ", error) {")
	g.P("\tif t.q == nil {")
	g.P("\t\treturn nil, errors.New(\"" + errNilDBTX + "\")")
	g.P("\t}")
	g.P("\tctx := context.Background()")
	g.P("\tquery := `SELECT id, at_ns, data FROM \"`+", tableNameConst, "+`\"`")
	g.P("\tif strings.TrimSpace(where) != \"\" {")
	g.P("\t\tquery += \" WHERE \" + where")
	g.P("\t}")
	g.P("\trows, err := t.q.QueryContext(ctx, query, args...)")
	g.P("\tif err != nil {")
	g.P("\t\treturn nil, fmt.Errorf(\"select from %s: %w\", ", tableNameConst, ", err)")
	g.P("\t}")
	g.P("\tresult := make([]", model.RowTypeName, ", 0)")
	g.P("\tfor rows.Next() {")
	g.P("\t\tvar id string")
	g.P("\t\tvar atNs int64")
	g.P("\t\tvar dataBytes []byte")
	g.P("\t\tif err := rows.Scan(&id, &atNs, &dataBytes); err != nil {")
	g.P("\t\t\tif closeErr := rt.CloseRows(rows, \"select\"); closeErr != nil {")
	g.P("\t\t\t\treturn nil, fmt.Errorf(\"scan row from %s: %w (additionally, %v)\", ", tableNameConst, ", err, closeErr)")
	g.P("\t\t\t}")
	g.P("\t\t\treturn nil, fmt.Errorf(\"scan row from %s: %w\", ", tableNameConst, ", err)")
	g.P("\t\t}")
	g.P("\t\tdata := &", model.GoName, "{}")
	g.P("\t\tif err := proto.Unmarshal(dataBytes, data); err != nil {")
	g.P("\t\t\tif closeErr := rt.CloseRows(rows, \"select\"); closeErr != nil {")
	g.P("\t\t\t\treturn nil, fmt.Errorf(\"unmarshal ", model.GoName, " row: %w (additionally, %v)\", err, closeErr)")
	g.P("\t\t\t}")
	g.P("\t\t\treturn nil, fmt.Errorf(\"unmarshal ", model.GoName, " row: %w\", err)")
	g.P("\t\t}")
	g.P("\t\tresult = append(result, ", model.RowTypeName, "{ID: id, AtNs: atNs, Data: data})")
	g.P("\t}")
	g.P("\tif err := rows.Err(); err != nil {")
	g.P("\t\tif closeErr := rt.CloseRows(rows, \"select\"); closeErr != nil {")
	g.P("\t\t\treturn nil, fmt.Errorf(\"iterate rows from %s: %w (additionally, %v)\", ", tableNameConst, ", err, closeErr)")
	g.P("\t\t}")
	g.P("\t\treturn nil, fmt.Errorf(\"iterate rows from %s: %w\", ", tableNameConst, ", err)")
	g.P("\t}")
	g.P("\tif err := rt.CloseRows(rows, \"select\"); err != nil {")
	g.P("\t\treturn nil, err")
	g.P("\t}")
	g.P("\treturn result, nil")
	g.P("}")
	g.P()
}

func (e generatorEmitter) emitInsertMethod(model messageModel, tableNameConst, insertConst string) {
	g := e.g
	g.P("func (t *", model.TableTypeName, ") Insert(data *", model.GoName, ") (", model.RowTypeName, ", error) {")
	g.P("\tif t.q == nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, errors.New(\""+errNilDBTX+"\")")
	g.P("\t}")
	g.P("\tif data == nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, errors.New(\""+errNilData+"\")")
	g.P("\t}")
	g.P("\tid, err := rt.UUIDv7()")
	g.P("\tif err != nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, fmt.Errorf(\"generate uuidv7: %w\", err)")
	g.P("\t}")
	g.P("\tif err := rt.ValidateUUID(id); err != nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, fmt.Errorf(\"validate generated id %s: %w\", id, err)")
	g.P("\t}")
	g.P("\treturn t.insertWithID(id, data)")
	g.P("}")
	g.P()

	if model.AllowCustomIDInsert {
		g.P("func (t *", model.TableTypeName, ") InsertWithID(id string, data *", model.GoName, ") (", model.RowTypeName, ", error) {")
		g.P("\tif t.q == nil {")
		g.P("\t\treturn ", model.RowTypeName, "{}, errors.New(\""+errNilDBTX+"\")")
		g.P("\t}")
		g.P("\tif data == nil {")
		g.P("\t\treturn ", model.RowTypeName, "{}, errors.New(\""+errNilData+"\")")
		g.P("\t}")
		g.P("\treturn t.insertWithID(id, data)")
		g.P("}")
		g.P()
	}

	g.P("func (t *", model.TableTypeName, ") insertWithID(id string, data *", model.GoName, ") (", model.RowTypeName, ", error) {")
	g.P("\tif t.q == nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, errors.New(\""+errNilDBTX+"\")")
	g.P("\t}")
	g.P("\tif data == nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, errors.New(\""+errNilData+"\")")
	g.P("\t}")
	g.P("\tif id == \"\" {")
	g.P("\t\treturn ", model.RowTypeName, "{}, errors.New(\""+errEmptyID+"\")")
	g.P("\t}")
	g.P("\tif err := rt.ValidateUUID(id); err != nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, fmt.Errorf(\"validate id %s: %w\", id, err)")
	g.P("\t}")
	if model.ValidateWrite {
		g.P("\tif err := data.Valid(); err != nil {")
		g.P("\t\treturn ", model.RowTypeName, "{}, fmt.Errorf(\"validate ", model.GoName, ": %w\", err)")
		g.P("\t}")
	}
	g.P("\tctx := context.Background()")
	g.P("\tatNs := rt.NowNs()")
	g.P("\tdataBytes, err := proto.Marshal(data)")
	g.P("\tif err != nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, fmt.Errorf(\"marshal ", model.GoName, ": %w\", err)")
	g.P("\t}")
	g.P("\tif _, err := t.q.ExecContext(ctx, `DELETE FROM _deleted WHERE table_name = ? AND id = ?`, ", tableNameConst, ", id); err != nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, fmt.Errorf(\"delete tombstone for %s/%s: %w\", ", tableNameConst, ", id, err)")
	g.P("\t}")
	g.P("\tinsertArgs := []any{id, atNs, dataBytes}")
	for _, projectedField := range model.ProjectedFields {
		g.P("\tinsertArgs = append(insertArgs, data.", projectedField.GetterName, "())")
	}
	g.P("\tif _, err := t.q.ExecContext(ctx, ", insertConst, ", insertArgs...); err != nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, fmt.Errorf(\"insert into %s: %w\", ", tableNameConst, ", err)")
	g.P("\t}")
	g.P("\treturn ", model.RowTypeName, "{ID: id, AtNs: atNs, Data: data}, nil")
	g.P("}")
	g.P()
}

func (e generatorEmitter) emitUpdateMethod(model messageModel, tableNameConst, upsertConst string) {
	g := e.g
	g.P("func (t *", model.TableTypeName, ") UpdateByID(id string, data *", model.GoName, ") (", model.RowTypeName, ", error) {")
	g.P("\tif t.q == nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, errors.New(\""+errNilDBTX+"\")")
	g.P("\t}")
	g.P("\tif id == \"\" {")
	g.P("\t\treturn ", model.RowTypeName, "{}, errors.New(\""+errEmptyID+"\")")
	g.P("\t}")
	g.P("\tif err := rt.ValidateUUID(id); err != nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, fmt.Errorf(\"validate id %s: %w\", id, err)")
	g.P("\t}")
	g.P("\tif data == nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, errors.New(\""+errNilData+"\")")
	g.P("\t}")
	if model.ValidateWrite {
		g.P("\tif err := data.Valid(); err != nil {")
		g.P("\t\treturn ", model.RowTypeName, "{}, fmt.Errorf(\"validate ", model.GoName, ": %w\", err)")
		g.P("\t}")
	}
	g.P("\tctx := context.Background()")
	g.P("\tatNs := rt.NowNs()")
	g.P("\tdataBytes, err := proto.Marshal(data)")
	g.P("\tif err != nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, fmt.Errorf(\"marshal ", model.GoName, ": %w\", err)")
	g.P("\t}")
	g.P("\tif _, err := t.q.ExecContext(ctx, `DELETE FROM _deleted WHERE table_name = ? AND id = ?`, ", tableNameConst, ", id); err != nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, fmt.Errorf(\"delete tombstone for %s/%s: %w\", ", tableNameConst, ", id, err)")
	g.P("\t}")
	g.P("\tupdateArgs := []any{id, atNs, dataBytes}")
	for _, projectedField := range model.ProjectedFields {
		g.P("\tupdateArgs = append(updateArgs, data.", projectedField.GetterName, "())")
	}
	g.P("\tif _, err := t.q.ExecContext(ctx, ", upsertConst, ", updateArgs...); err != nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, fmt.Errorf(\"upsert into %s: %w\", ", tableNameConst, ", err)")
	g.P("\t}")
	g.P("\treturn ", model.RowTypeName, "{ID: id, AtNs: atNs, Data: data}, nil")
	g.P("}")
	g.P()

	g.P("func (t *", model.TableTypeName, ") UpdateRow(row ", model.RowTypeName, ") (", model.RowTypeName, ", error) {")
	g.P("\tif t.q == nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, errors.New(\""+errNilDBTX+"\")")
	g.P("\t}")
	g.P("\tif row.ID == \"\" {")
	g.P("\t\treturn ", model.RowTypeName, "{}, errors.New(\""+errEmptyID+"\")")
	g.P("\t}")
	g.P("\tif row.Data == nil {")
	g.P("\t\treturn ", model.RowTypeName, "{}, errors.New(\""+errNilData+"\")")
	g.P("\t}")
	g.P("\treturn t.UpdateByID(row.ID, row.Data)")
	g.P("}")
	g.P()
}

func (e generatorEmitter) emitDeleteMethod(model messageModel, tableNameConst string) {
	g := e.g
	g.P("func (t *", model.TableTypeName, ") DeleteByID(id string) error {")
	g.P("\tif t.q == nil {")
	g.P("\t\treturn errors.New(\"" + errNilDBTX + "\")")
	g.P("\t}")
	g.P("\tif id == \"\" {")
	g.P("\t\treturn errors.New(\"" + errEmptyID + "\")")
	g.P("\t}")
	g.P("\tctx := context.Background()")
	g.P("\tatNs := rt.NowNs()")
	g.P("\tif _, err := t.q.ExecContext(ctx, `INSERT INTO _deleted (table_name, id, at_ns) VALUES (?, ?, ?) ON CONFLICT(table_name, id) DO UPDATE SET at_ns = excluded.at_ns`, ", tableNameConst, ", id, atNs); err != nil {")
	g.P("\t\treturn fmt.Errorf(\"insert tombstone for %s/%s: %w\", ", tableNameConst, ", id, err)")
	g.P("\t}")
	g.P("\tif _, err := t.q.ExecContext(ctx, `DELETE FROM \"`+", tableNameConst, "+`\" WHERE id = ?`, id); err != nil {")
	g.P("\t\treturn fmt.Errorf(\"delete from %s/%s: %w\", ", tableNameConst, ", id, err)")
	g.P("\t}")
	g.P("\treturn nil")
	g.P("}")
	g.P()

	g.P("func (t *", model.TableTypeName, ") DeleteRow(row ", model.RowTypeName, ") error {")
	g.P("\tif t.q == nil {")
	g.P("\t\treturn errors.New(\"" + errNilDBTX + "\")")
	g.P("\t}")
	g.P("\tif row.ID == \"\" {")
	g.P("\t\treturn errors.New(\"" + errEmptyID + "\")")
	g.P("\t}")
	g.P("\treturn t.DeleteByID(row.ID)")
	g.P("}")
	g.P()
}

func (e generatorEmitter) emitApplyWithAtNsMethods(model messageModel, tableNameConst, upsertConst string) {
	g := e.g
	g.P("func (t *", model.TableTypeName, ") upsertWithAtNs(id string, atNs int64, data *", model.GoName, ") error {")
	g.P("\tif t.q == nil {")
	g.P("\t\treturn errors.New(\"" + errNilDBTX + "\")")
	g.P("\t}")
	g.P("\tif id == \"\" {")
	g.P("\t\treturn errors.New(\"" + errEmptyID + "\")")
	g.P("\t}")
	g.P("\tif data == nil {")
	g.P("\t\treturn errors.New(\"" + errNilData + "\")")
	g.P("\t}")
	g.P("\tctx := context.Background()")
	g.P("\tdataBytes, err := proto.Marshal(data)")
	g.P("\tif err != nil {")
	g.P("\t\treturn fmt.Errorf(\"marshal ", model.GoName, ": %w\", err)")
	g.P("\t}")
	g.P("\tif _, err := t.q.ExecContext(ctx, `DELETE FROM _deleted WHERE table_name = ? AND id = ?`, ", tableNameConst, ", id); err != nil {")
	g.P("\t\treturn fmt.Errorf(\"delete tombstone for %s/%s: %w\", ", tableNameConst, ", id, err)")
	g.P("\t}")
	g.P("\tupsertArgs := []any{id, atNs, dataBytes}")
	for _, projectedField := range model.ProjectedFields {
		g.P("\tupsertArgs = append(upsertArgs, data.", projectedField.GetterName, "())")
	}
	g.P("\tif _, err := t.q.ExecContext(ctx, ", upsertConst, ", upsertArgs...); err != nil {")
	g.P("\t\treturn fmt.Errorf(\"upsert into %s: %w\", ", tableNameConst, ", err)")
	g.P("\t}")
	g.P("\treturn nil")
	g.P("}")
	g.P()
	g.P("func (t *", model.TableTypeName, ") tombstoneWithAtNs(id string, atNs int64) error {")
	g.P("\tif t.q == nil {")
	g.P("\t\treturn errors.New(\"" + errNilDBTX + "\")")
	g.P("\t}")
	g.P("\tif id == \"\" {")
	g.P("\t\treturn errors.New(\"" + errEmptyID + "\")")
	g.P("\t}")
	g.P("\tctx := context.Background()")
	g.P("\tif _, err := t.q.ExecContext(ctx, `INSERT INTO _deleted (table_name, id, at_ns) VALUES (?, ?, ?) ON CONFLICT(table_name, id) DO UPDATE SET at_ns = excluded.at_ns`, ", tableNameConst, ", id, atNs); err != nil {")
	g.P("\t\treturn fmt.Errorf(\"insert tombstone for %s/%s: %w\", ", tableNameConst, ", id, err)")
	g.P("\t}")
	g.P("\tif _, err := t.q.ExecContext(ctx, `DELETE FROM \"`+", tableNameConst, "+`\" WHERE id = ?`, id); err != nil {")
	g.P("\t\treturn fmt.Errorf(\"delete from %s/%s: %w\", ", tableNameConst, ", id, err)")
	g.P("\t}")
	g.P("\treturn nil")
	g.P("}")
	g.P()
}

func (e generatorEmitter) emitReprojectMethod(model messageModel, tableNameConst, reprojectConst string) {
	g := e.g
	g.P("func (t *", model.TableTypeName, ") reproject() error {")
	g.P("\tctx := context.Background()")
	g.P("\trows, err := t.q.QueryContext(ctx, `SELECT id, data FROM \"`+", tableNameConst, "+`\"`)")
	g.P("\tif err != nil {")
	g.P("\t\treturn fmt.Errorf(\"query rows for reprojection: %w\", err)")
	g.P("\t}")
	g.P("\ttype reprojectRow struct {")
	g.P("\t\tid string")
	g.P("\t\tdataBytes []byte")
	g.P("\t}")
	g.P("\trowBuffer := make([]reprojectRow, 0)")
	g.P("\tfor rows.Next() {")
	g.P("\t\tvar id string")
	g.P("\t\tvar dataBytes []byte")
	g.P("\t\tif err := rows.Scan(&id, &dataBytes); err != nil {")
	g.P("\t\t\treturn fmt.Errorf(\"scan reprojection row: %w\", err)")
	g.P("\t\t}")
	g.P("\t\tcopiedData := make([]byte, len(dataBytes))")
	g.P("\t\tcopy(copiedData, dataBytes)")
	g.P("\t\trowBuffer = append(rowBuffer, reprojectRow{id: id, dataBytes: copiedData})")
	g.P("\t}")
	g.P("\tif err := rows.Err(); err != nil {")
	g.P("\t\treturn fmt.Errorf(\"iterate reprojection rows: %w\", err)")
	g.P("\t}")
	g.P("\tif err := rows.Close(); err != nil {")
	g.P("\t\treturn fmt.Errorf(\"close reprojection rows: %w\", err)")
	g.P("\t}")
	g.P("\tfor _, row := range rowBuffer {")
	g.P("\t\tdata := &", model.GoName, "{}")
	g.P("\t\tif err := proto.Unmarshal(row.dataBytes, data); err != nil {")
	g.P("\t\t\treturn fmt.Errorf(\"unmarshal reprojection row: %w\", err)")
	g.P("\t\t}")
	g.P("\t\treprojectArgs := []any{}")
	for _, projectedField := range model.ProjectedFields {
		g.P("\t\treprojectArgs = append(reprojectArgs, data.", projectedField.GetterName, "())")
	}
	g.P("\t\treprojectArgs = append(reprojectArgs, row.id)")
	g.P("\t\tif _, err := t.q.ExecContext(ctx, ", reprojectConst, ", reprojectArgs...); err != nil {")
	g.P("\t\t\treturn fmt.Errorf(\"reproject row %s: %w\", row.id, err)")
	g.P("\t\t}")
	g.P("\t}")
	g.P("\treturn nil")
	g.P("}")
	g.P()
}

func (e generatorEmitter) emitWrapper(models []messageModel) {
	g := e.g
	syncModels := make([]messageModel, 0, len(models))
	for _, model := range models {
		if !model.OmitSync {
			syncModels = append(syncModels, model)
		}
	}

	g.P("type CRUD struct {")
	for _, model := range models {
		g.P("\t", model.GoName, " *", model.TableTypeName)
	}
	g.P("}")
	g.P()
	g.P("func NewCRUD(q DBTX) *CRUD {")
	g.P("\treturn &CRUD{")
	for _, model := range models {
		g.P("\t\t", model.GoName, ": New", model.TableTypeName, "(q),")
	}
	g.P("\t}")
	g.P("}")
	g.P()
	g.P("func (c *CRUD) dbtx() (DBTX, error) {")
	g.P("\tif c == nil {")
	g.P("\t\treturn nil, errors.New(\"nil CRUD\")")
	g.P("\t}")
	for _, model := range models {
		g.P("\tif c.", model.GoName, " != nil && c.", model.GoName, ".q != nil {")
		g.P("\t\treturn c.", model.GoName, ".q, nil")
		g.P("\t}")
	}
	g.P("\treturn nil, errors.New(\"" + errNilDBTX + "\")")
	g.P("}")
	g.P()
	g.P("func (c *CRUD) Init() error {")
	for _, model := range models {
		g.P("\tif err := c.", model.GoName, ".Init(); err != nil {")
		g.P("\t\treturn fmt.Errorf(\"init ", model.GoName, " table: %w\", err)")
		g.P("\t}")
	}
	g.P("\treturn nil")
	g.P("}")
	g.P()
	g.P("func (c *CRUD) WriteJSONL(remote string, w io.Writer) error {")
	g.P("\tif w == nil {")
	g.P("\t\treturn errors.New(\"nil writer\")")
	g.P("\t}")
	g.P("\tq, err := c.dbtx()")
	g.P("\tif err != nil {")
	g.P("\t\treturn err")
	g.P("\t}")
	g.P("\tencoder := json.NewEncoder(w)")
	for _, model := range syncModels {
		g.P("\t", strings.ToLower(model.GoName), "Rows, err := c.", model.GoName, ".Select(\"\")")
		g.P("\tif err != nil {")
		g.P("\t\treturn fmt.Errorf(\"select ", model.GoName, " rows for jsonl write: %w\", err)")
		g.P("\t}")
		g.P("\tfor _, row := range ", strings.ToLower(model.GoName), "Rows {")
		g.P("\t\tneedsSend, err := rt.SyncNeedsSend(q, row.ID, ", model.GoName, "TableName, remote, row.AtNs)")
		g.P("\t\tif err != nil {")
		g.P("\t\t\treturn err")
		g.P("\t\t}")
		g.P("\t\tif !needsSend {")
		g.P("\t\t\tcontinue")
		g.P("\t\t}")
		g.P("\t\tdataJSON, err := rt.MarshalAnyJSON(row.Data)")
		g.P("\t\tif err != nil {")
		g.P("\t\t\treturn fmt.Errorf(\"marshal ", model.GoName, " %s for jsonl write: %w\", row.ID, err)")
		g.P("\t\t}")
		g.P("\t\trecord := proprdbJSONLRecord{ID: row.ID, AtNs: row.AtNs, Data: dataJSON}")
		g.P("\t\tif err := encoder.Encode(record); err != nil {")
		g.P("\t\t\treturn fmt.Errorf(\"write jsonl row for ", model.GoName, " %s: %w\", row.ID, err)")
		g.P("\t\t}")
		g.P("\t\tif err := rt.SyncUpsert(q, row.ID, ", model.GoName, "TableName, remote, row.AtNs); err != nil {")
		g.P("\t\t\treturn err")
		g.P("\t\t}")
		g.P("\t}")
	}
	if len(syncModels) > 0 {
		tableNameCases := make([]string, 0, len(syncModels))
		for _, model := range syncModels {
			tableNameCases = append(tableNameCases, model.GoName+"TableName")
		}
		placeholders := strings.TrimRight(strings.Repeat("?,", len(syncModels)), ",")
		g.P("\ttombstoneRows, err := q.QueryContext(context.Background(), `SELECT table_name, id, at_ns FROM _deleted WHERE table_name IN ("+placeholders+")`, ", strings.Join(tableNameCases, ", "), ")")
		g.P("\tif err != nil {")
		g.P("\t\treturn fmt.Errorf(\"select tombstones for jsonl write: %w\", err)")
		g.P("\t}")
		g.P("\tfor tombstoneRows.Next() {")
		g.P("\t\tvar tableName string")
		g.P("\t\tvar id string")
		g.P("\t\tvar atNs int64")
		g.P("\t\tif err := tombstoneRows.Scan(&tableName, &id, &atNs); err != nil {")
		g.P("\t\t\tif closeErr := rt.CloseRows(tombstoneRows, \"tombstone sync\"); closeErr != nil {")
		g.P("\t\t\t\treturn fmt.Errorf(\"scan tombstone row: %w (additionally, %v)\", err, closeErr)")
		g.P("\t\t\t}")
		g.P("\t\t\treturn fmt.Errorf(\"scan tombstone row: %w\", err)")
		g.P("\t\t}")
		g.P("\t\tneedsSend, err := rt.SyncNeedsSend(q, id, tableName, remote, atNs)")
		g.P("\t\tif err != nil {")
		g.P("\t\t\treturn err")
		g.P("\t\t}")
		g.P("\t\tif !needsSend {")
		g.P("\t\t\tcontinue")
		g.P("\t\t}")
		g.P("\t\tvar typeName string")
		g.P("\t\tswitch tableName {")
		for _, model := range syncModels {
			g.P("\t\tcase ", model.GoName, "TableName:")
			g.P("\t\t\ttypeName = ", model.GoName, "TypeName")
		}
		g.P("\t\tdefault:")
		g.P("\t\t\treturn fmt.Errorf(\"unsupported tombstone table %s\", tableName)")
		g.P("\t\t}")
		g.P("\t\tdataJSON, err := rt.MarshalTypeOnlyAnyJSON(typeName)")
		g.P("\t\tif err != nil {")
		g.P("\t\t\treturn fmt.Errorf(\"marshal tombstone %s/%s for jsonl write: %w\", tableName, id, err)")
		g.P("\t\t}")
		g.P("\t\trecord := proprdbJSONLRecord{ID: id, Deleted: true, AtNs: atNs, Data: dataJSON}")
		g.P("\t\tif err := encoder.Encode(record); err != nil {")
		g.P("\t\t\treturn fmt.Errorf(\"write jsonl tombstone %s/%s: %w\", tableName, id, err)")
		g.P("\t\t}")
		g.P("\t\tif err := rt.SyncUpsert(q, id, tableName, remote, atNs); err != nil {")
		g.P("\t\t\tif closeErr := rt.CloseRows(tombstoneRows, \"tombstone sync\"); closeErr != nil {")
		g.P("\t\t\t\treturn fmt.Errorf(\"sync tombstone %s/%s: %w (additionally, %v)\", tableName, id, err, closeErr)")
		g.P("\t\t\t}")
		g.P("\t\t\treturn err")
		g.P("\t\t}")
		g.P("\t}")
		g.P("\tif err := tombstoneRows.Err(); err != nil {")
		g.P("\t\tif closeErr := rt.CloseRows(tombstoneRows, \"tombstone sync\"); closeErr != nil {")
		g.P("\t\t\treturn fmt.Errorf(\"iterate tombstone rows: %w (additionally, %v)\", err, closeErr)")
		g.P("\t\t}")
		g.P("\t\treturn fmt.Errorf(\"iterate tombstone rows: %w\", err)")
		g.P("\t}")
		g.P("\tif err := rt.CloseRows(tombstoneRows, \"tombstone sync\"); err != nil {")
		g.P("\t\treturn err")
		g.P("\t}")
	}
	g.P("\treturn nil")
	g.P("}")
	g.P()
	g.P("func (c *CRUD) ReadJSONL(remote string, r io.Reader) error {")
	g.P("\tif r == nil {")
	g.P("\t\treturn errors.New(\"nil reader\")")
	g.P("\t}")
	g.P("\tq, err := c.dbtx()")
	g.P("\tif err != nil {")
	g.P("\t\treturn err")
	g.P("\t}")
	g.P("\treturn rt.ReadJSONL(r, func(record proprdbJSONLRecord, lineNumber int) error {")
	g.P("\t\tif record.ID == \"\" {")
	g.P("\t\t\treturn fmt.Errorf(\"jsonl line %d has empty id\", lineNumber)")
	g.P("\t\t}")
	g.P("\t\tif len(record.Data) == 0 {")
	g.P("\t\t\treturn fmt.Errorf(\"jsonl line %d has empty data\", lineNumber)")
	g.P("\t\t}")
	g.P("\t\tanyMessage := &anypb.Any{}")
	g.P("\t\tif err := protojson.Unmarshal(record.Data, anyMessage); err != nil {")
	g.P("\t\t\treturn fmt.Errorf(\"unmarshal jsonl data on line %d: %w\", lineNumber, err)")
	g.P("\t\t}")
	g.P("\t\ttypeName := rt.TypeNameFromURL(anyMessage.GetTypeUrl())")
	g.P("\t\tswitch typeName {")
	for _, model := range models {
		g.P("\t\tcase ", model.GoName, "TypeName:")
		if model.OmitSync {
			g.P("\t\t\tslog.Error(\"ignoring unsynced jsonl record\", \"type\", typeName, \"id\", record.ID, \"remote\", remote, \"line\", lineNumber)")
			g.P("\t\t\treturn nil")
			continue
		}
		g.P("\t\t\tlocalMaxAtNs, err := rt.LocalMaxAtNs(q, ", model.GoName, "TableName, record.ID)")
		g.P("\t\t\tif err != nil {")
		g.P("\t\t\t\treturn err")
		g.P("\t\t\t}")
		g.P("\t\t\tif err := rt.SyncUpsert(q, record.ID, ", model.GoName, "TableName, remote, record.AtNs); err != nil {")
		g.P("\t\t\t\treturn err")
		g.P("\t\t\t}")
		g.P("\t\t\tif record.AtNs < localMaxAtNs {")
		g.P("\t\t\t\treturn nil")
		g.P("\t\t\t}")
		g.P("\t\t\tif record.Deleted {")
		g.P("\t\t\t\tif c.", model.GoName, " == nil {")
		g.P("\t\t\t\t\treturn errors.New(\"nil ", model.GoName, " table\")")
		g.P("\t\t\t\t}")
		g.P("\t\t\t\treturn c.", model.GoName, ".tombstoneWithAtNs(record.ID, record.AtNs)")
		g.P("\t\t\t}")
		g.P("\t\t\tif c.", model.GoName, " == nil {")
		g.P("\t\t\t\treturn errors.New(\"nil ", model.GoName, " table\")")
		g.P("\t\t\t}")
		g.P("\t\t\tdata := &", model.GoName, "{}")
		g.P("\t\t\tif err := anypb.UnmarshalTo(anyMessage, data, proto.UnmarshalOptions{}); err != nil {")
		g.P("\t\t\t\treturn fmt.Errorf(\"unmarshal ", model.GoName, " data on line %d: %w\", lineNumber, err)")
		g.P("\t\t\t}")
		g.P("\t\t\treturn c.", model.GoName, ".upsertWithAtNs(record.ID, record.AtNs, data)")
	}
	g.P("\t\tdefault:")
	g.P("\t\t\treturn fmt.Errorf(\"unsupported @type on line %d: %s\", lineNumber, typeName)")
	g.P("\t\t}")
	g.P("\t})")
	g.P("}")
	g.P()
}

func (m messageModel) createTableSQL() string {
	columns := []string{`"id" TEXT PRIMARY KEY`, `"at_ns" INTEGER NOT NULL`, `"data" BLOB NOT NULL`}
	for _, projectedField := range m.ProjectedFields {
		columns = append(
			columns,
			fmt.Sprintf(
				`"%s" %s NOT NULL DEFAULT %s`,
				projectedField.ColumnName,
				projectedField.SQLiteType,
				projectedField.SQLiteDefault,
			),
		)
	}

	return fmt.Sprintf(
		`CREATE TABLE IF NOT EXISTS "%s" (%s)`,
		m.TableName,
		strings.Join(columns, ", "),
	)
}

func (m messageModel) insertSQL(upsert bool) string {
	columns := []string{"id", "at_ns", "data"}
	for _, projectedField := range m.ProjectedFields {
		columns = append(columns, projectedField.ColumnName)
	}

	quotedColumns := make([]string, 0, len(columns))
	for _, column := range columns {
		quotedColumns = append(quotedColumns, fmt.Sprintf(`"%s"`, column))
	}

	placeholders := make([]string, 0, len(columns))
	for range columns {
		placeholders = append(placeholders, "?")
	}

	statement := fmt.Sprintf(
		`INSERT INTO "%s" (%s) VALUES (%s)`,
		m.TableName,
		strings.Join(quotedColumns, ", "),
		strings.Join(placeholders, ", "),
	)
	if !upsert {
		return statement
	}

	updates := []string{`"at_ns" = excluded."at_ns"`, `"data" = excluded."data"`}
	for _, projectedField := range m.ProjectedFields {
		updates = append(
			updates,
			fmt.Sprintf(
				`"%s" = excluded."%s"`,
				projectedField.ColumnName,
				projectedField.ColumnName,
			),
		)
	}

	return statement + " ON CONFLICT(id) DO UPDATE SET " + strings.Join(updates, ", ")
}

func (m messageModel) reprojectSQL() string {
	updates := make([]string, 0, len(m.ProjectedFields))
	for _, projectedField := range m.ProjectedFields {
		updates = append(updates, fmt.Sprintf(`"%s" = ?`, projectedField.ColumnName))
	}

	return fmt.Sprintf(
		`UPDATE "%s" SET %s WHERE id = ?`,
		m.TableName,
		strings.Join(updates, ", "),
	)
}

func (m messageModel) generatedIndexPrefix() string {
	return "idx_" + sanitizeSQLName(m.TableName) + "__"
}

func (m messageModel) createIndexSQL(indexModel messageIndex) string {
	quotedColumns := make([]string, 0, len(indexModel.ColumnNames))
	for _, columnName := range indexModel.ColumnNames {
		quotedColumns = append(quotedColumns, fmt.Sprintf(`"%s"`, columnName))
	}
	return fmt.Sprintf(`CREATE INDEX IF NOT EXISTS "%s" ON "%s" (%s)`, indexModel.IndexName, m.TableName, strings.Join(quotedColumns, ", "))
}
